{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Bosch Sensortec offers a toolkit for evaluation of it\u2019s sensor products.The toolkit consisting of 3 elements:</p> <ul> <li>A sensor specific shuttle board also known as breakout board. APP3.0 shuttle boards also known as mini shuttle boards has smaller form factor when compared with APP2.0 shuttle board.</li> </ul> <p> </p> Fig. 1: APP2.0/3.0 shuttle board <ul> <li>Application Board has a connector for the shuttle board and serves as interface translator from the sensor interface (I<sub>2</sub>C or SPI) to a USB interface, allowing PC software to communicate with the sensor on the shuttle.</li> </ul> <p> </p> Fig. 2: Application Board 2.0/3.0 <ul> <li>Nicla Sense ME board combines four state-of-the-art sensors from Bosch Sensortec (BHI260AP, BMP390, BMM150 and BME688) in the Arduino ecosystem.</li> </ul> <p> </p> Fig. 3: Nicla Sense ME <ul> <li> <p>On the PC side, Bosch Sensortec provides the software packages Development Desktop 2.0 and COINES to connect to the sensor on the Application Board.</p> <ul> <li> <p>Development Desktop 2.0 provides a GUI which allows to configure the sensor, plot and export streamed sensor data.</p> </li> <li> <p>COINES provides a C based interface, which allows to communicate with the sensor using the SensorAPI from Bosch Sensortec on the PC side.</p> </li> <li> <p>Starting from COINES v2.0, user has an option to cross-compile the example and run it directly on the Application Board\u2019s microcontroller.</p> </li> </ul> </li> </ul>"},{"location":"data_protection_notice_for_coines/","title":"Data Protection Notice for COINES","text":""},{"location":"data_protection_notice_for_coines/#1-data-protection-notice","title":"1. Data Protection Notice","text":"<p>Bosch Sensortec GmbH (hereinafter \"BST\" or \"We\" or \"Us\") welcomes you to our documentation of COINES (\"COmmunication with INertial and Environmental Sensors\") (referred to as \"software\"). We thank you for your interest in our company and our product. </p>"},{"location":"data_protection_notice_for_coines/#2-bst-respects-your-privacy","title":"2. BST respects your privacy","text":"<p>The protection of your privacy throughout the course of processing personal data as well as the security of all business data are important concerns to us. We process personal data that was gathered during your use of the software confidentially and only in accordance with statutory regulations. </p> <p>Data protection and information security are included in our corporate policy. </p>"},{"location":"data_protection_notice_for_coines/#3-controller","title":"3. Controller","text":"<p>BST is the controller responsible for the processing of your data; exceptions are outlined in this data protection notice.  </p> <p>Our contact details are as follows : </p> <p>Bosch Sensortec GmbH  Gerhard-Kindler-Strasse 9  72770 Reutlingen  GERMANY </p>"},{"location":"data_protection_notice_for_coines/#4-collection-processing-and-usage-of-personal-data","title":"4. Collection, processing and usage of personal data","text":""},{"location":"data_protection_notice_for_coines/#41-processed-categories-of-data","title":"4.1. Processed categories of data","text":"<p>No personal data is collected by us. </p>"},{"location":"data_protection_notice_for_coines/#42-principles","title":"4.2. Principles","text":"<p>Personal data consists of all information related to an identified or identifiable natural person, this includes, e.g., names, addresses, phone numbers, email addresses, contractual master data, contract accounting and payment data, which is an expression of a person's identity. </p>"},{"location":"data_protection_notice_for_coines/#421-safeguarding-and-defending-our-rights","title":"4.2.1. Safeguarding and defending our rights.","text":"<p>Legal basis: Legitimate interest on our part for safeguarding and defending our rights. </p>"},{"location":"data_protection_notice_for_coines/#43-log-files","title":"4.3. Log files","text":"<p>Log files are not and will not be used. </p>"},{"location":"data_protection_notice_for_coines/#44-data-processing-by-operator-of-the-platform","title":"4.4. Data processing by Operator of the Platform","text":"<p>We do not collect data, and it is beyond our responsibility, when data, such as E.g. username, email address and individual device identifier are transferred to GitHub whose platform is used for this offer. GitHub\u2019s data protection notice can be found here.  </p> <p>Our employees and the companies providing services on our behalf, are obliged to confidentiality and to compliance with the applicable data protection laws. </p> <p>We take all necessary technical and organizational measures to ensure an appropriate level of security and to protect your data that are administrated by us especially from the risks of unintended or unlawful destruction, manipulation, loss, change or unauthorized disclosure or unauthorized access. Our security measures are, pursuant to technological progress, constantly being improved. </p>"},{"location":"data_protection_notice_for_coines/#5-user-rights","title":"5. User Rights","text":"<p>To enforce your rights, please use the details provided for doing so, please ensure that an unambiguous identification of your person is possible. </p>"},{"location":"data_protection_notice_for_coines/#51-right-to-information-and-access","title":"5.1. Right to information and access","text":"<p>You have the right to obtain confirmation from us about whether your personal data is being processed, and, if this is the case, access to your personal data.  </p>"},{"location":"data_protection_notice_for_coines/#52-right-to-correction-and-deletion","title":"5.2. Right to correction and deletion","text":"<p>You have the right to obtain the rectification of inaccurate personal data. As far as statutory requirements are fulfilled, you have the right to obtain the completion or deletion of your data.  </p> <p>This does not apply to data which is necessary for billing or accounting purposes, or which is subject to a statutory retention period. If access to such data is not required, however, its processing is restricted (see the following). </p>"},{"location":"data_protection_notice_for_coines/#53-restriction-of-processing","title":"5.3. Restriction of processing","text":"<p>As far as statutory requirements are fulfilled you have the right to demand for restriction of the processing of your data. </p>"},{"location":"data_protection_notice_for_coines/#54-data-portability","title":"5.4. Data portability","text":"<p>As far as statutory requirements are fulfilled you may request to receive data that you have provided to us in a structured, commonly used and machine-readable format or \u2013 if technically feasible \u2013that we transfer those data to a third party. </p>"},{"location":"data_protection_notice_for_coines/#6-right-to-lodge-complaint-with-supervisory-authority","title":"6. Right to lodge complaint with supervisory authority:","text":"<p>You have the right to lodge a complaint with a supervisory authority. You can appeal to the supervisory authority which is responsible for your place of residence or your state of residency or to the supervisory authority responsible for us. This is: </p> <p>State Commissioner for Data Protection and Freedom of Information  </p> <p>Address:  Lautenschlagerstra\u00dfe 20  70173 Stuttgart, GERMANY </p> <p>Postal address:  P.O. Box 10 29 32  70025 Stuttgart, GERMANY  </p> <p>Phone: +49 (711)/615541-0  Fax: +49 (711)/615541-15   Email: poststelle@lfdi.bwl.de </p>"},{"location":"data_protection_notice_for_coines/#7-changes-to-the-data-protection-notice","title":"7. Changes to the Data Protection Notice","text":"<p>We reserve the right to change our security and data protection measures. In such cases, we will amend our data protection notice accordingly. Please, therefore, notice the current version of our data protection notice, as this is subject to changes. </p>"},{"location":"data_protection_notice_for_coines/#8-contact","title":"8. Contact","text":"<p>If you wish to contact us, please find us at the address stated in the \"Controller\" section. </p> <p>To assert your rights please use the following link: https://request.privacy-bosch.com/entity/RB/ </p> <p>To notify us about data protection incidents please use this link: https://www.bkms-system.net/bosch-dataprotection </p> <p>For suggestions and complaints regarding the processing of your personal data we recommend that you contact our data protection officer: </p> <p>Data Protection Officer  Information Security and Privacy (C/ISP)  Robert Bosch GmbH  P.O. Box 30 02 20  70442 Stuttgart, GERMANY  or  Email: DPO@bosch.com </p>"},{"location":"data_protection_notice_for_coines/#effective-date","title":"Effective date","text":"<p>Effective Date : 10th of October 2023 </p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#1-i-want-to-upgrade-app20app30-firmware","title":"1. I want to upgrade APP2.0/APP3.0 firmware.","text":"<ul> <li>Use <code>app20-flash</code> tool (or) Development Desktop to upgrade APP2.0 firmware.</li> <li>Use <code>dfu-util</code> tool to upgrade APP3.0 firmware.</li> </ul>"},{"location":"faq/#2-why-gcc-is-chosen-as-the-compiler","title":"2. Why GCC is chosen as the compiler?","text":"<p>GCC is widely used and available in both Linux and Windows environments. However, if the user uses a different compiler, it should be easy to migrate the code, since no compiler-specific tweaks are needed.</p>"},{"location":"faq/#3-why-do-you-use-tdm-gcc-in-windows","title":"3. Why do you use TDM-GCC in Windows?","text":"<p>It is a complete toolchain in a single installer, but does not come with too much overhead the COINES user most likely does not need. The installation procedures for other toolchains are more complicated and especially for in-experienced users difficult to handle.</p>"},{"location":"faq/#4-why-do-you-use-mingw32-make-in-windows","title":"4. Why do you use mingw32-make in Windows?","text":"<p>It comes as a part of TDM-GCC package and can handle Windows path names better compared e.g. with MSYS make. The usage of spaces in path names can be overcome using 8.3 naming format.</p>"},{"location":"faq/#5-what-to-do-in-case-of-any-communication-or-initialization-failure-while-running-examples","title":"5. What to do in case of any communication or initialization failure while running examples?","text":"<p>Resetting or rebooting the board will help solving this.    </p>"},{"location":"faq/#6-what-does-app_switch-tool-do","title":"6. What does 'app_switch' tool do?","text":"<p>'app_switch' tool can command the Application Board to jump to a specified address on RAM or FLASH. It works only with APP2.0 firmware v3.1 or later. COINES uses this feature to jump to USB DFU Bootloader or example application.</p>"},{"location":"faq/#7-are-libraries-provided-by-microcontroller-vendor-used-for-coines-on-mcu-implementation","title":"7. Are libraries provided by microcontroller vendor used for COINES on MCU implementation ?","text":"<p>Yes ! ASF v3.42 (Advanced Software Framework) and nRF5 SDK v15.2 is being used for APP2.0 and APP3.0. One can download the latest version of libraries from the below links</p> <ul> <li>https://www.microchip.com/mplab/avr-support/advanced-software-framework</li> <li>https://developer.nordicsemi.com/nRF5_SDK/</li> </ul>"},{"location":"faq/#8-how-is-the-binary-file-from-pc-downloaded-to-ram-or-flash-memory-of-mcu","title":"8. How is the binary file from PC downloaded to RAM or Flash memory of MCU?","text":"<p>USB DFU protocol and open-source 'dfu-util' is used.</p> <ul> <li>USB DFU Specification - https://www.usb.org/sites/default/files/DFU_1.1.pdf</li> <li>dfu-util Homepage - http://dfu-util.sourceforge.net/</li> </ul>"},{"location":"faq/#9-why-is-there-no-output-in-my-terminal-application-not-stream-data-after-cross-compiling-and-downloading-an-example-on-the-mcu","title":"9. Why is there no output in my terminal application not stream data after cross-compiling and downloading an example on the MCU?","text":"<p>The code example on the MCU waits until the serial port of the board is opened. However, opening the port is not enough, the user has to ensure that also the DTR signal is set (this is required due to have higher compatibiliy among different terminal applications).</p>"},{"location":"faq/#10-why-can-some-examples-only-be-compiled-for-either-pc-or-mcu-target","title":"10. Why can some examples only be compiled for either PC or MCU target?","text":"<ul> <li>Examples which make use of APIs like <code>coines_config_streaming</code>, <code>coines_read_stream_sensor_data</code> etc., are meant to work only on PC.</li> <li>Use of APIs like <code>coines_attach_interrupt</code> in example will make it only compatible with MCU.  </li> <li>Constraints can also be introduced by the use of POSIX C library. Eg:Functions from <code>time.h</code>, <code>pthread.h</code>, etc.</li> </ul>"},{"location":"legal_disclaimer/","title":"Legal disclaimer","text":""},{"location":"legal_disclaimer/#engineering-samples","title":"Engineering samples","text":"<p>Engineering Samples are marked with an asterisk (*), (E) or (e). Samples may vary from the valid technical specifications of the product series contained in this data sheet. They are therefore not intended or fit for resale to third parties or for use in end products. Their sole purpose is internal client testing. The testing of an engineering sample may in no way replace the testing of a product series. Bosch Sensortec assumes no liability for the use of engineering samples. The Purchaser shall indemnify Bosch Sensortec from all claims arising from the use of engineering samples.</p>"},{"location":"legal_disclaimer/#product-use","title":"Product use","text":"<p>Bosch Sensortec products are developed for the consumer goods industry. They may only be used within the parameters of this product data sheet. They are not fit for use in life-sustaining or safety-critical systems. Safety-critical systems are those for which a malfunction is expected to lead to bodily harm, death or severe property damage. In addition, they shall not be used directly or indirectly for military purposes (including but not limited to nuclear, chemical or biological proliferation of weapons or development of missile technology), nuclear power, deep sea or space applications (including but not limited to satellite technology).</p> <p>The resale and/or use of Bosch Sensortec products are at the purchaser\u2019s own risk and his own responsibility. The examination of fitness for the intended use is the sole responsibility of the purchaser.</p> <p>The purchaser shall indemnify Bosch Sensortec from all third party claims arising from any product use not covered by the parameters of this product data sheet or not approved by Bosch Sensortec and reimburse Bosch Sensortec for all costs in connection with such claims.</p> <p>The purchaser accepts the responsibility to monitor the market for the purchased products, particularly with regard to product safety, and to inform Bosch Sensortec without delay of all safety-critical incidents.</p>"},{"location":"legal_disclaimer/#application-examples-and-hints","title":"Application examples and hints","text":"<p>With respect to any examples or hints given herein, any typical values stated herein and/or any information regarding the application of the device, Bosch Sensortec hereby disclaims any and all warranties and liabilities of any kind, including without limitation warranties of non-infringement of intellectual property rights or copyrights of any third party. The information given in this document shall in no event be regarded as a guarantee of conditions or characteristics. They are provided for illustrative purposes only and no evaluation regarding infringement of intellectual property rights or copyrights or regarding functionality, performance or error has been made.</p>"},{"location":"accessing_the_sensor_on_application_board/introduction_to_coines/","title":"Introduction to COINES","text":"<p>COINES (\"COmmunication with INertial and Environmental Sensors\") provides a low-level interface to Bosch Sensortec\u2019s Application Board. The user can access Bosch Sensortec\u2019s MEMS sensors through a C interface. COINES can be used with SensorAPI of the sensor. SensorAPI is available at https://github.com/BoschSensortec. The source code of example applications and SensorAPI are provided with the COINES library as a package. The user can modify, compile and run the sample applications.</p> <p>COINES can be used to see how to use the SensorAPI in an embedded environment and allows convenient data logging.</p> <p>The full working environment consists of:</p> <ul> <li>A Bosch Sensortec MEMS sensor on a shuttle board mounted on the socket of Bosch Sensortec\u2019s application board APP2.0/APP3.0</li> <li>Windows or Linux PC to which the Application Board is connected via USB</li> <li>COINES software release as found here: http://www.bosch-sensortec.com</li> <li>C compiler is also required (details see below)</li> </ul>"},{"location":"accessing_the_sensor_on_application_board/running_examples_directly_on_the_mcu_of_the_application_board/","title":"Running examples directly on the MCU of the Application board","text":"<p>The examples can also be cross-compiled on PC side and downloaded into the memory of the Application board and executed there. The user can choose to download the created binary into the flash memory or into the RAM (if the binary is not too big).</p> <p>Important is that the example is placed in a location in the flash memory other than where the default firmware is stored. The example is executed with a specific command, allowing to jump to the start address of the complied example from the default firmware. As the firmware itself is not overwritten, the board always returns to its default state after a power-off-power-on cycle.</p> <p>In this configuration the COINES layer provides a simple abstraction on top of the MCU BSP (i.e. board level support layer of the microcontroller). Any printf command will now not output to the console, but rather to the USB connection, which appears as virtual COM port on PC side.</p> <p>This mode allows to also perform many time-critical operations on the sensor, such as fast reading of FIFO content at high data rates.</p> <p> </p> Fig. 5: Working principle: running example on the MCU of the Application Board"},{"location":"accessing_the_sensor_on_application_board/running_examples_on_pc_side/","title":"Running examples on PC side","text":"<p>When compiling the examples for PC side, the COINES layer provides an abstraction of the embedded environment on the host side. COINES library provides read and write functions for I<sub>2</sub>C and SPI on PC side. These functions receive the arguments of the user input (i.e. what register address to read from) and tunnel them through the USB connection to the Application Board, where they are fed into the embedded I<sub>2</sub>C and SPI functions and are executed to access the sensor Any result or response from those functions is tunneled back to the PC side and provided to the example application.</p> <p>This approach allows easy and flexible programming and offers the possibility to integrate the example code into other applications or add advanced logging options. The drawback is that in this mode the code is not executed in real time, as it runs on a multi-tasking operating system To overcome this drawback, the examples can also be run on the MCU side (see next section).</p> <p> </p> Fig. 4: Working principle: running example on PC side"},{"location":"accessing_the_sensor_on_nicla_sense_me/coines_on_nicla_sense_me/","title":"COINES on Nicla Sense ME","text":"<p>COINES can be used to access the onboard Bosch sensors with the Nicla Sense ME. The working environment consists of windows or Linux PC to which the Nicla Sense ME Board is connected via USB. For details refer to section 2.</p>"},{"location":"coines_api/overview_of_pc_side_implementation_of_coines/","title":"Overview of PC side implementation of COINES","text":"<p>Bosch Sensortec recommends using the SensorAPI in order to communicate with the sensors. The SensorAPI , an abstraction layer written in C makes it much more convenient for the user to access the register map of the sensor in order to configure certain functionality and obtain certain information from it.</p> <p>For making use of the SensorAPI, three function pointers must be set to the appropriate read/write functions of the selected bus on the system (either I<sub>2</sub>C or SPI), as well as one function pointer to a system's function causing delays in milliseconds.</p> <p>In order to execute C code using SensorAPI on a PC, the coinesAPI provides the mentioned read,write,delay functions. These functions are wrapper functions, embedding the actual SensorAPI payloads into a transport package, sending this via USB to the APP2.0, where the payload is translated into corresponding SPI or I<sub>2</sub>C messages and sent to the sensor on the shuttle board. The mapping would look similar to the one below.</p> <pre><code>#include \"bst_sensor.h\"\n\nstruct bst_sensor_dev sensordev;\n....\n....\nsensordev.dev_id = I2C_ADDR;        // SPI - CS PIN\nsensordev.read = coines_read_i2c;   // coines_read_spi\nsensordev.write = coines_write_i2c; // coines_write_spi\nsensordev.delay_ms = coines_delay_msec;\n</code></pre> <p>Using this method, the full functionality of the SensorAPI can be used on PC side, sample code can be modified and tested, and data can be logged in a convenient way.</p> <p>This setup has the challenge of lacking the real-time capabilities known from a pure microcontroller environment. To overcome this, the coinesAPI offers streaming functions, which allow the user to schedule data readout directly on the microcontroller, either based on a data interrupt coming from the sensors or based on the timer of the microcontroller. The scheduler waits for the configured interrupt (sensor interrupt or timer interrupt) and reads out areas of the register map, which can be configured by the user.</p> <p>As an example, the user could choose to read out the 6 bytes from the register map of a certain inertial sensor, containing the sensor data of three axis (2 bytes per axis). If the user would configure for example a readout once per milliseconds, the result would be a data stream of three-axis sensor data at a rate of 1 kHz.</p>"},{"location":"coines_api/api_calls/streaming_feature/","title":"coinesAPI calls: Streaming feature","text":"<p>Note:</p> <ul> <li>The below APIs are supported only on PC Target.</li> <li>A simpler approach of using <code>coines_attach_interrupt()</code> API for is available for MCU.</li> </ul>"},{"location":"coines_api/api_calls/gpio_oriented_calls/coines_get_pin_config/","title":"coines_get_pin_config","text":"<p>Gets the pin configuration.</p> <pre><code>int16_t coines_get_pin_config(enum coines_multi_io_pin pin_number, enum coines_pin_direction *pin_direction, enum coines_pin_value *pin_value);\n</code></pre>"},{"location":"coines_api/api_calls/gpio_oriented_calls/coines_set_pin_config/","title":"coines_set_pin_config","text":"<p>Sets the pin direction and the state.</p> <pre><code>int16_t coines_set_pin_config(enum coines_multi_io_pin pin_number, enum coines_pin_direction direction, enum coines_pin_value pin_value);  \n</code></pre>"},{"location":"coines_api/api_calls/gpio_oriented_calls/coines_set_shuttleboard_vdd_vddio_config/","title":"coines_set_shuttleboard_vdd_vddio_config","text":"<p>Configures the VDD and VDDIO of the sensor. For APP2.0, a voltage level of 0 or 3300 mV is supported. Any values above 0 will default to 3300 mV.</p> <pre><code>int16_t coines_set_shuttleboard_vdd_vddio_config(uint16_t vdd_millivolt, uint16_t vddio_millivolt);\n</code></pre>"},{"location":"coines_api/api_calls/interface_and_board_information/coines_close_comm_intf/","title":"coines_close_comm_intf","text":"<p>Closes the communication interface.</p> <pre><code>int16_t coines_close_comm_intf(enum coines_comm_intf intf_type,void *arg); \n</code></pre>"},{"location":"coines_api/api_calls/interface_and_board_information/coines_get_board_info/","title":"coines_get_board_info","text":"<p>Gets the board information.</p> <pre><code>int16_t coines_get_board_info(struct coines_board_info *data);\n</code></pre> <p>The data structure contains the following items:</p> <pre><code>struct coines_board_info {\n    /*!Board hardware ID */\n    uint16_t hardware_id;\n    /*!Board software ID */\n    uint16_t software_id;\n    /*!Type of the board like APP2.0, Arduino Due*/\n    uint8_t board;\n    /*!Shuttle ID of the sensor connected*/\n    uint16_t shuttle_id;\n};\n</code></pre>"},{"location":"coines_api/api_calls/interface_and_board_information/coines_open_comm_intf/","title":"coines_open_comm_intf","text":"<p>Opens the communication interface. Currently only <code>COINES_COMM_INTF_USB</code> (USB Connection) interface is available. <code>COINES_COMM_INTF_BLE</code> is available for <code>MCU_APP30</code> target.</p> <p>In case of MCU Target, API waits indefinitely for serial port or BLE connection (<code>MCU_APP30</code> target only).</p> <p>In order to use <code>fprintf</code> and <code>fscanf</code> with BLE, <code>intf_type</code> should be <code>COINES_COMM_INTF_BLE</code></p> <pre><code>int16_t coines_open_comm_intf(enum coines_comm_intf intf_type,void *arg); \n</code></pre>"},{"location":"coines_api/api_calls/other_api/coines_attach_interrupt/","title":"coines_attach_interrupt","text":"<p>Attaches an interrupt to a Multi-IO pin. Works only on MCU.</p> <pre><code>void coines_attach_interrupt(enum coines_multi_io_pin pin_number,void (*callback)(uint32_t, uint32_t),enum coines_pin_interrupt_mode int_mode);\n</code></pre> <p>Arguments:</p> <ul> <li><code>pin_number</code>:  Multi-IO pin</li> <li><code>callback</code>: Name of the function to be called on detection of interrupt</li> <li><code>int_mode</code>: Trigger modes - change (<code>COINES_PIN_INTERRUPT_CHANGE</code>), rising edge (<code>COINES_PIN_INTERRUPT_RISING_EDGE</code>), falling edge (<code>COINES_PIN_INTERRUPT_FALLING_EDGE</code>)</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_attach_timed_interrupt/","title":"coines_attach_timed_interrupt","text":"<p>Attaches a timed interrupt to a Multi-IO pin.</p> <pre><code>int16_t coines_attach_timed_interrupt(enum coines_multi_io_pin pin_number, \n    void (*timed_interrupt_cb)(uint64_t,uint32_t,uint32_t), enum coines_pin_interrupt_mode\n    int_mode);\n</code></pre> <p>Arguments:</p> <ul> <li><code>pin_number</code>: Multi-IO pin.</li> <li><code>timed_interrupt_cb</code>:  Name of the function to be called on detection of interrupt.</li> <li><code>int_mode</code>: Trigger modes - change, rising edge,  falling edge.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_ble_config/","title":"coines_ble_config","text":"<p>This API is used to configure BLE name and power. It should be called before calling coines_open_comm_intf API.</p> <pre><code>int16_t coines_ble_config(struct coines_ble_config *ble_config);\n</code></pre> <p>Arguments:</p> <ul> <li><code>ble_config</code>: structure holding ble name and power details.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_delay_realtime_usec/","title":"coines_delay_realtime_usec","text":"<p>This API is used to introduce delay based on high precision RTC(LFCLK crystal) with the resolution of 30.517 usec.</p> <pre><code>void coines_delay_realtime_usec(uint32_t period);\n</code></pre> <p>Arguments:</p> <ul> <li><code>period</code>: required delay in microseconds. </li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_detach_interrupt/","title":"coines_detach_interrupt","text":"<p>Detaches interrupt from a Multi-IO pin. Works only on MCU.</p> <pre><code>void coines_detach_interrupt(enum coines_multi_io_pin pin_number);\n</code></pre> <p>Arguments:</p> <ul> <li><code>pin_number</code> : Multi-IO pin.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_detach_timed_interrupt/","title":"coines_detach_timed_interrupt","text":"<p>Detaches a timed interrupt from a Multi-IO pin.</p> <pre><code>int16_t coines_detach_timed_interrupt(enum coines_multi_io_pin pin_number);\n</code></pre> <p>Arguments:</p> <ul> <li><code>pin_number</code> : Multi-IO pin.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_echo_test/","title":"coines_echo_test","text":"<p>This API is used to test the communication.</p> <pre><code>int16_t coines_echo_test(uint8_t *data, uint16_t length);\n</code></pre> <p>Arguments:</p> <ul> <li> <p><code>data</code> : Data to be sent for testing.</p> </li> <li> <p><code>length</code> :  Length of the data.</p> </li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_execute_critical_region/","title":"coines_execute_critical_region","text":"<p>This API is used to execute the function inside critical region.</p> <pre><code>void coines_execute_critical_region(coines_critical_callback callback);\n</code></pre> <p>Arguments:</p> <ul> <li><code>callback</code> : function to execute.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_flush_intf/","title":"coines_flush_intf","text":"<p>Flush the write buffer.Works only on APP3.0 MCU target.</p> <pre><code>void coines_flush_intf(enum coines_comm_intf intf);\n</code></pre> <p>Arguments:</p> <ul> <li><code>intf</code>: Type of interface (USB, COM, or BLE)</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_get_micro_sec/","title":"coines_get_micro_sec","text":"<p>Returns the number of microseconds passed since the program started.</p> <pre><code>uint64_t coines_get_micro_sec();\n</code></pre>"},{"location":"coines_api/api_calls/other_api/coines_get_millis/","title":"coines_get_millis","text":"<p>Returns the number of milliseconds passed since the program started.</p> <pre><code>uint32_t coines_get_millis();\n</code></pre>"},{"location":"coines_api/api_calls/other_api/coines_get_realtime_usec/","title":"coines_get_realtime_usec","text":"<p>This API is used to get the current counter(RTC) reference time in usec.</p> <pre><code>uint32_t coines_get_realtime_usec(void);\n</code></pre>"},{"location":"coines_api/api_calls/other_api/coines_get_version/","title":"coines_get_version","text":"<p>Returns pointer to COINES version string</p> <pre><code>char* coines_get_version(void);\n</code></pre>"},{"location":"coines_api/api_calls/other_api/coines_intf_available/","title":"coines_intf_available","text":"<p>Return the number of bytes available in the read buffer of the interface. Works only on APP3.0 MCU target.</p> <pre><code>uint16_t coines_intf_available(enum coines_comm_intf intf);\n</code></pre> <p>Arguments:</p> <ul> <li><code>intf</code>: Type of interface (USB, COM, or BLE)</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_intf_connected/","title":"coines_intf_connected","text":"<p>Check if the interface is connected.Works only on APP3.0 MCU target.</p> <pre><code>bool coines_intf_connected(enum coines_comm_intf intf);\n</code></pre> <p>Arguments:</p> <ul> <li><code>intf</code>: Type of interface (USB, COM, or BLE)</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_read_bat_status/","title":"coines_read_bat_status","text":"<p>This API is used to read the battery status.</p> <pre><code>int16_t coines_read_bat_status(uint16_t *bat_status_mv, uint8_t *bat_status_percent);\n</code></pre> <p>Arguments:</p> <ul> <li><code>bat_status_mv</code>: Buffer to retrieve the battery status in millivolt.</li> <li><code>bat_status_percent</code>: Buffer to retrieve the battery status in percentage.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_read_intf/","title":"coines_read_intf","text":"<p>Read data over the specified interface.Works only on APP3.0 MCU target.</p> <pre><code>uint16_t coines_read_intf(enum coines_comm_intf intf, void *buffer, uint16_t len);\n</code></pre> <p>Arguments:</p> <ul> <li><code>intf</code>: Type of interface (USB, COM, or BLE)</li> <li><code>buffer</code>: Pointer to the buffer to store the data</li> <li><code>len</code>: Length of the buffer</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_read_temp_data/","title":"coines_read_temp_data","text":"<p>This API is used to read the temperature sensor data.</p> <pre><code>int16_t coines_read_temp_data(float *temp_data);\n</code></pre> <p>Arguments:</p> <ul> <li><code>temp_data</code>: Buffer to retrieve the sensor data in degree Celsius.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_scan_ble_devices/","title":"coines_scan_ble_devices","text":"<p>This API is used to connect to BLE Adapter and return list of BLE peripherals found during BLE scan. <pre><code>int8_t coines_scan_ble_devices(struct ble_peripheral_info *ble_info, uint8_t\n*peripheral_count, size_t scan_timeout_ms)\n</code></pre></p> <p>Arguments:</p> <ul> <li> <p><code>ble_info</code> :  array of struct containing found BLE peripheral information.</p> </li> <li> <p><code>peripheral_count</code> :  number of BLE peripherals found.</p> </li> <li> <p><code>scan_timeout_ms</code> : timeout for BLE scan.</p> </li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_set_led/","title":"coines_set_led","text":"<p>This API is used to set led state(on or off).</p> <pre><code>int16_t coines_set_led(enum coines_led led,enum coines_led_state led_state);\n</code></pre> <p>Arguments:</p> <ul> <li><code>led</code>: led whose state has to be set.</li> <li><code>led_state</code>: state to be set to the given led.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_shuttle_eeprom_read/","title":"coines_shuttle_eeprom_read","text":"<p>This API is used to read the content from shuttle eeprom.</p> <pre><code>int16_t coines_shuttle_eeprom_read(uint16_t start_addr, uint8_t *buffer, \n    uint16_t length);\n</code></pre> <p>Arguments:</p> <ul> <li> <p><code>start_addr</code> : EEPROM read address.</p> </li> <li> <p><code>buffer</code> : Pointer to the buffer.</p> </li> <li> <p><code>length</code> : Length of the buffer.</p> </li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_shuttle_eeprom_write/","title":"coines_shuttle_eeprom_write","text":"<p>This API is used to write the content into shuttle eeprom.</p> <pre><code>int16_t coines_shuttle_eeprom_write(uint16_t start_addr, uint8_t *buffer, uint16_t length);\n</code></pre> <p>Arguments:</p> <ul> <li> <p><code>start_addr</code> : EEPROM write address.</p> </li> <li> <p><code>buffer</code> : Pointer to the buffer.</p> </li> <li> <p><code>length</code> : Length of the buffer.</p> </li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_soft_reset/","title":"coines_soft_reset","text":"<p>Resets the device. After reset device jumps to the address specified in makefile(APP_START_ADDRESS). <pre><code>void coines_soft_reset(void);\n</code></pre></p>"},{"location":"coines_api/api_calls/other_api/coines_timer_config/","title":"coines_timer_config","text":"<p>This API is used to configure the hardware timer.</p> <pre><code>int16_t coines_timer_config(enum coines_timer_instance instance, void* handler);\n</code></pre> <p>Arguments:</p> <ul> <li><code>instance</code>: timer instance.</li> <li><code>handler</code>: callback to be called when timer expires.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_timer_deconfig/","title":"coines_timer_deconfig","text":"<p>This API is used to de-configure the hardware timer.</p> <pre><code>int16_t coines_timer_deconfig(enum coines_timer_instance instance);\n</code></pre> <p>Arguments:</p> <ul> <li><code>instance</code>: timer instance.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_timer_start/","title":"coines_timer_start","text":"<p>This API is used to start the configured hardware timer.</p> <pre><code>int16_t coines_timer_start(enum coines_timer_instance instance, uint32_t timeout);\n</code></pre> <p>Arguments:</p> <ul> <li><code>instance</code>: timer instance.</li> <li><code>timeout</code>: timeout in microseconds.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_timer_stop/","title":"coines_timer_stop","text":"<p>This API is used to stop the  hardware timer.</p> <pre><code>int16_t coines_timer_stop(enum coines_timer_instance instance);\n</code></pre> <p>Arguments:</p> <ul> <li><code>instance</code>: timer instance.</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_write_intf/","title":"coines_write_intf","text":"<p>Write data over the specified interface.Works only on APP3.0 MCU target.</p> <pre><code>uint16_t coines_write_intf(enum coines_comm_intf intf, void *buffer, uint16_t len);\n</code></pre> <p>Arguments:</p> <ul> <li><code>intf</code>: Type of interface (USB, COM, or BLE)</li> <li><code>buffer</code>: Pointer to the buffer storing the data</li> <li><code>len</code>: Length of the buffer</li> </ul>"},{"location":"coines_api/api_calls/other_api/coines_yield/","title":"coines_yield","text":"<p>This API can be defined to perform a task when yielded from an ongoing blocking call.</p> <pre><code>void coines_yield(void);\n</code></pre>"},{"location":"coines_api/api_calls/sensor_communication/coines_config_i2c_bus/","title":"coines_config_i2c_bus","text":"<p>Configures the I<sub>2</sub>C bus. </p> <pre><code>int16_t coines_config_i2c_bus(enum coines_i2c_bus bus, enum coines_i2c_mode i2c_mode);\n</code></pre> <p>The first argument refers to the bus on the board. Currently, on APP2.0, there is only one bus available, so the argument is always <code>COINES_I2C_BUS_0</code>.</p> <p>The following I<sub>2</sub>C modes are available: <pre><code>COINES_I2C_STANDARD_MODE\nCOINES_I2C_FAST_MODE\nCOINES_I2C_SPEED_3_4_MHZ\nCOINES_I2C_SPEED_1_7_MHZ\n</code></pre></p>"},{"location":"coines_api/api_calls/sensor_communication/coines_config_i2s_bus/","title":"coines_config_i2s_bus","text":"<p>This API is used to configure the I2S bus to match the TDM configuration</p> <pre><code>int16_t coines_config_i2s_bus(uint16_t data_words, coines_tdm_callback callback);\n</code></pre> <p>Arguments:</p> <ul> <li><code>data_words</code>: number of words to use in the buffer. Max is set at <code>COINES_TDM_BUFFER_SIZE_WORDS</code>.</li> <li><code>callback</code>: register a callback to be called to process and copy the data.</li> </ul>"},{"location":"coines_api/api_calls/sensor_communication/coines_config_spi_bus/","title":"coines_config_spi_bus","text":"<p>Configures the SPI bus of the board. The argument coines_spi_bus refers to the bus on the board. On APP2.0, there is only one bus available, so the user should only use <code>COINES_SPI_BUS_0</code>. The SPI speed can be chosen in various discrete steps, as defined in enum coines_spi_speed in coines.h (For example, <code>COINES_SPI_SPEED_2_MHZ</code> sets the SPI speed to 2 MHz).</p> <pre><code>int16_t coines_config_spi_bus(enum coines_spi_bus bus, uint32_t spi_speed, enum coines_spi_mode spi_mode);\n</code></pre>"},{"location":"coines_api/api_calls/sensor_communication/coines_config_word_spi_bus/","title":"coines_config_word_spi_bus","text":"<p>Configures the SPI bus parameters speed, mode, 8-bit/16-bit transfer ( <code>COINES_SPI_TRANSFER_8BIT</code> / <code>COINES_SPI_TRANSFER_16BIT</code> ).</p> <pre><code>int16_t coines_config_word_spi_bus(enum coines_spi_bus bus, enum coines_spi_speed spi_speed, enum coines_spi_mode spi_mode, enum coines_spi_transfer_bits spi_transfer_bits);\n</code></pre>"},{"location":"coines_api/api_calls/sensor_communication/coines_deconfig_i2c_bus/","title":"coines_deconfig_i2c_bus","text":"<p>This API is used to de-configure the I<sub>2</sub>C bus.</p> <pre><code>int16_t coines_deconfig_i2c_bus(enum coines_i2c_bus bus);\n</code></pre>"},{"location":"coines_api/api_calls/sensor_communication/coines_deconfig_i2s_bus/","title":"coines_deconfig_i2s_bus","text":"<p>This API is used to stop the I2S/TDM interface from reading data from the sensor.</p> <pre><code>void coines_deconfig_i2s_bus(void);\n</code></pre>"},{"location":"coines_api/api_calls/sensor_communication/coines_deconfig_spi_bus/","title":"coines_deconfig_spi_bus","text":"<p>This API is used to de-configure the SPI bus.</p> <pre><code>int16_t coines_deconfig_spi_bus(enum coines_spi_bus bus);\n</code></pre>"},{"location":"coines_api/api_calls/sensor_communication/coines_delay_msec/","title":"coines_delay_msec","text":"<p>Introduces delay in millisecond.</p> <pre><code>void coines_delay_msec(uint32_t delay_ms);\n</code></pre>"},{"location":"coines_api/api_calls/sensor_communication/coines_delay_usec/","title":"coines_delay_usec","text":"<p>Introduces delay in microsecond.</p> <pre><code>void coines_delay_usec(uint32_t delay_us);\n</code></pre>"},{"location":"coines_api/api_calls/sensor_communication/coines_i2c_get/","title":"coines_i2c_get","text":"<p>This API is used to read the data in I2C communication</p> <pre><code>int8_t coines_i2c_get(enum coines_i2c_bus bus, uint8_t dev_addr, uint8_t *data, uint8_t\ncount);\n</code></pre> <p>Arguments:</p> <ul> <li>bus: I2C bus to be used.</li> <li>dev_addr: I2C device address.</li> <li>data: Data read from the sensor.</li> <li>count: Number of bytes to read.</li> </ul>"},{"location":"coines_api/api_calls/sensor_communication/coines_i2c_set/","title":"coines_i2c_set","text":"<p>This API is used to write the data in I2C communication.</p> <pre><code>int8_t coines_i2c_set(enum coines_i2c_bus bus, uint8_t dev_addr, uint8_t *data, uint8_t count);\n</code></pre> <p>Arguments:</p> <ul> <li>bus: I2C bus to be used</li> <li>dev_addr: I2C device address.</li> <li>data: Data to be written.</li> <li>count: Number of bytes to write.</li> </ul>"},{"location":"coines_api/api_calls/sensor_communication/coines_read_16bit_spi/","title":"coines_read_16bit_spi","text":"<p>Reads 16-bit register data from the SPI device at <code>COINES_SPI_BUS_0</code>.</p> <pre><code>int8_t coines_read_16bit_spi(enum coines_spi_bus bus, uint8_t cs, uint16_t reg_addr, void *reg_data, uint16_t count);\n</code></pre> <p>Arguments:</p> <ul> <li><code>bus</code>: SPI bus to be used.</li> <li><code>cs</code>: Chip select pin number.</li> <li><code>reg_addr</code>: Starting address for reading the data.</li> <li><code>reg_data</code>: Buffer to take up the read data.</li> <li><code>count</code>: Number of bytes to read.</li> </ul>"},{"location":"coines_api/api_calls/sensor_communication/coines_read_i2c/","title":"coines_read_i2c","text":"<p>Reads 8-bit register data from the I<sub>2</sub>C device at <code>COINES_I2C_BUS_0</code>.</p> <pre><code>int8_t coines_read_i2c(enum coines_i2c_bus bus,uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t count);\n</code></pre> <p>Arguments:</p> <ul> <li><code>bus</code>: I<sub>2</sub>C bus to be used.</li> <li><code>dev_addr</code>: I<sub>2</sub>C device address.</li> <li><code>reg_addr</code>: Starting address for reading the data.</li> <li><code>reg_data</code>: Buffer to take up the read data.</li> <li><code>count</code>: Number of bytes to read.</li> </ul>"},{"location":"coines_api/api_calls/sensor_communication/coines_read_spi/","title":"coines_read_spi","text":"<p>Reads 8-bit register data from the SPI device at <code>COINES_SPI_BUS_0</code>.</p> <pre><code>int8_t coines_read_spi(enum coines_spi_bus bus,uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t count);\n</code></pre> <p>Arguments:</p> <ul> <li><code>bus</code>: SPI bus to be used.</li> <li><code>dev_addr</code>: Chip select pin number.</li> <li><code>reg_addr</code>: Starting address for reading the data.</li> <li><code>reg_data</code>: Buffer to take up the read data.</li> <li><code>count</code>: Number of bytes to read.</li> </ul>"},{"location":"coines_api/api_calls/sensor_communication/coines_write_16bit_spi/","title":"coines_write_16bit_spi","text":"<p>Writes 16-bit register data to the SPI device at <code>COINES_SPI_BUS_0</code>.</p> <pre><code>int8_t coines_write_16bit_spi(enum coines_spi_bus bus, uint8_t cs, uint16_t reg_addr, void *reg_data, uint16_t count);\n</code></pre> <p>Arguments:</p> <ul> <li><code>bus</code>: SPI bus to be used.</li> <li><code>cs</code>: Chip select pin number.</li> <li><code>reg_addr</code>: Starting address for writing the data.</li> <li><code>reg_data</code>: Data to be written.</li> <li><code>count</code>: Number of bytes to write.</li> </ul>"},{"location":"coines_api/api_calls/sensor_communication/coines_write_i2c/","title":"coines_write_i2c","text":"<p>Writes 8-bit register data to the I<sub>2</sub>C device at <code>COINES_I2C_BUS_0</code>.</p> <pre><code>int8_t coines_write_i2c(enum coines_i2c_bus bus,uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t count);\n</code></pre> <p>Arguments:</p> <ul> <li><code>bus</code>: I<sub>2</sub>C bus to be used.</li> <li><code>dev_addr</code>: I<sub>2</sub>C device address.</li> <li><code>reg_addr</code>: Starting address for writing the data.</li> <li><code>reg_data</code>: Data to be written.</li> <li><code>count</code>: Number of bytes to write.</li> </ul>"},{"location":"coines_api/api_calls/sensor_communication/coines_write_spi/","title":"coines_write_spi","text":"<p>Writes 8-bit register data to the SPI device at <code>COINES_SPI_BUS_0</code>.</p> <pre><code>int8_t coines_write_spi(enum coines_spi_bus bus,uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t count);\n</code></pre> <p>Arguments:</p> <ul> <li><code>bus</code>: SPI bus to be used.</li> <li><code>dev_addr</code>: Chip select pin number.</li> <li><code>reg_addr</code>: Starting address for writing the data.</li> <li><code>reg_data</code>: Data to be written.</li> <li><code>count</code>: Number of bytes to write.</li> </ul>"},{"location":"coines_api/api_calls/streaming_feature/coines_config_streaming/","title":"coines_config_streaming","text":"<p>Sets the configuration for streaming sensor data.</p> <pre><code>int16_t coines_config_streaming(uint8_t channel_id, struct coines_streaming_config *stream_config, struct coines_streaming_blocks *data_blocks); \n</code></pre> <p>Arguments:</p> <ul> <li><code>channel_id</code>: An integer number that can be used as identifier/index to the sensor data that will be streamed for this setting.</li> <li><code>stream_config</code>: Contains information regarding interface settings and streaming configuration.</li> <li><code>coines_streaming_blocks</code>: Contains information regarding numbers of register blocks, range and size of  each block.</li> </ul> <p>Note:</p> <p>The below parameters should always be set:</p> <ul> <li><code>data_block.no_of_blocks</code>: number of blocks to stream (must at least be one).</li> <li>For each block b:<ul> <li><code>data_block.reg_start_addr[b]</code>: start address of the block in the register map.</li> <li><code>stream_block.no_of_data_bytes[b]</code>: number of addresses to read, starting from the start address.</li> </ul> </li> </ul> <p>For reading data from I<sub>2</sub>C bus,then set the below parameters:</p> <ul> <li><code>stream_config.intf = COINES_SENSOR_INTF_I2C;</code></li> <li><code>stream_config.i2c_bus</code>: I<sub>2</sub>C bus (in case of APP2.0, this is always <code>COINES_I2C_BUS_0</code>).</li> <li><code>stream_config.dev_addr</code>: I<sub>2</sub>C address of the sensor.</li> </ul> <p>For reading data from SPI bus, then set the below parameters:</p> <ul> <li><code>stream_config.intf = COINES_SENSOR_INTF_SPI;</code></li> <li><code>stream_config.spi_bus</code>: SPI bus (in case of APP2.0, this is always <code>COINES_SPI_BUS_0</code>).</li> <li><code>stream_config.cs_pin</code>: CS pin of the sensor, information can be obtained from the shuttle board documentation for the sensor. </li> </ul> <p>When polling mode is requested, set the below parameters:</p> <ul> <li> <p><code>stream_config.sampling_units</code>: either in milliseconds (<code>COINES_SAMPLING_TIME_IN_MILLI_SEC</code>) or in microseconds (<code>COINES_SAMPLING_TIME_IN_MICRO_SEC</code>)</p> </li> <li> <p><code>stream_config.sampling_time</code>: sampling period is in the unit as defined in <code>stream_config.sampling_units</code>.</p> </li> </ul> <p>When interrupt mode is requested, set the below parameters:</p> <ul> <li><code>stream_config.int_pin</code>: Pin of the interrupt which shall trigger the sensor read-out. If the interrupt output of the sensor is used, the required information about the pin number can be obtained from the shuttle board documentation for the sensor.</li> <li><code>stream_config.int_timestamp</code>:  It can be configured if the sensor data is tagged with a timestamp (<code>COINES_TIMESTAMP_ENABLE</code>) or not (<code>COINES_TIMESTAMP_DISABLE</code>).</li> </ul>"},{"location":"coines_api/api_calls/streaming_feature/coines_read_stream_sensor_data/","title":"coines_read_stream_sensor_data","text":"<p>Reads the data streamed from the sensor.</p> <pre><code>int16_t coines_read_stream_sensor_data(uint8_t sensor_id, uint32_t number_of_samples, uint8_t *data, uint32_t *valid_samples_count);\n</code></pre> <p>Arguments:</p> <ul> <li><code>sensor_id</code>: id of the sensor. </li> <li><code>number_of_samples</code>: number of samples the user wishes to read (not implemented).</li> <li><code>data</code>: data buffer.<ul> <li>Interrupt streaming - Packet counter + Register data + Timestamp</li> <li>Polling streaming - Register data.</li> </ul> </li> <li><code>valid_samples_count</code>: number of samples the user has actually received (may be less than <code>number_of_samples</code>).</li> </ul> <p>Example of a packet:</p> <p> </p> Fig. 13: Format of streaming packages <p>In the above figure, the following meaning apply to the mentioned abreviations:</p> <ul> <li>r<sub>p</sub>: Value at register address p.</li> <li>a: Size of register block\u20130.</li> <li>r<sub>p+a</sub>: Value at register address p.</li> </ul> <p>Similarly is the case for r<sub>q</sub>, j and r<sub>q+j</sub>. See the <code>coines_streaming_blocks</code> structure for information regarding register blocks.</p> <p>The packet counter and the timestamp can be obtained as follows:</p> <pre><code>packet_counter = (byte3_c &lt;&lt; 24) | (byte2_c &lt;&lt; 16) | (byte1_c &lt;&lt; 8) | (byte0_c);\ntimestamp = (byte5_t &lt;&lt; 40) | (byte4_t &lt;&lt; 32) | (byte3_t &lt;&lt; 24) | (byte2_t &lt;&lt; 16) | (byte1_t &lt;&lt; 8) | (byte0_t);\n</code></pre> <p>The 48-bit timestamp is enabled by using <code>coines_trigger_timer(COINES_TIMER_START,  COINES_TIMESTAMP_ENABLE);</code></p> <p>Timestamp in microseconds can be obtained using below formula:</p> \\[ Timestamp\\ (\\mu s) = \\frac{48bit\\_timestamp}{30}\\]"},{"location":"coines_api/api_calls/streaming_feature/coines_start_stop_streaming/","title":"coines_start_stop_streaming","text":"<p>Starts or stops sensor data streaming.</p> <pre><code>int16_t coines_start_stop_streaming(enum coines_streaming_mode stream_mode, uint8_t start_stop);\n</code></pre> <p>Arguments:</p> <ul> <li><code>stream_mode</code>: streaming mode (either <code>COINES_STREAMING_MODE_POLLING</code> or <code>COINES_STREAMING_MODE_INTERRUPT</code>).</li> <li><code>start_stop</code>: flag to either start (<code>COINES_STREAMING_START</code>) or stop (<code>COINES_STREAMING_STOP</code>) the streaming.</li> </ul>"},{"location":"coines_api/api_calls/streaming_feature/coines_trigger_timer/","title":"coines_trigger_timer","text":"<p>Triggers the timer in firmware and also enables or disables the time stamp feature.</p> <pre><code>int16_t coines_trigger_timer(enum coines_timer_config tmr_cfg,enum coines_time_stamp_config ts_cfg);\n</code></pre> <p>Arguments:</p> <ul> <li><code>tmr_cfg</code>: start, stop or reset the timer (<code>COINES_TIMER_START</code>, <code>COINES_TIMER_STOP</code> or <code>COINES_TIMER_RESET</code>). </li> <li><code>ts_cfg</code>: Enables/disables microcontroller timestamp  (<code>COINES_TIMESTAMP_ENABLE</code> or <code>COINES_TIMESTAMP_DISABLE</code>).</li> </ul>"},{"location":"coines_api/gpio_mapping/app20_shuttle_board/","title":"GPIO mapping of APP2.0 shuttle board pins","text":"<p>The APP2.0 shuttle board has total 28 pins, of which some have a predefined functionality and some can be used as GPIO by the user.</p> <p>The shuttle board connector details are given in the table below:</p> Pin number on shuttle board Name / function Pin number on shuttle board Name/function 1 VDD (3.3V) 28 SHTLE_COD #4 2 VDDIO (3.3V) 27 SHTLE_COD #3 3 GND 26 SHTLE_COD #2 4 SPI MISO 25 SHTLE_COD #1 5 SPI: MOSI / I<sub>2</sub>C: SDA 24 SHTLE_COD #0 6 SPI: SCK / I<sub>2</sub>C: SCL 23 SHTLE_COD_GND 7 SPI: CS 22 IO_4 ( GPIO #4 ) 8 IO_5 ( GPIO #5 ) 21 IO_7 ( GPIO #7 ) 9 IO_0 ( GPIO #0 ) 20 IO_6 ( GPIO #6 ) 10 SHTLE_COD #5 19 IO_8 ( GPIO #8 ) 11 SHTLE_COD #6 18 SCL (see note) 12 SHTLE_COD #7 17 SDA (see note) 13 SHTLE_COD #8 16 IO_3 ( GPIO #3 ) 14 IO_1 ( GPIO #1 ) 15 IO_2 ( GPIO #2 ) <p>Table 1: Overview of shuttle board pins and their functions</p> <p>Note:</p> <ul> <li>In coinesAPI the pins are addressed using the same numbers as on the shuttle board. For example, the GPIO #5 has the pin number 8.</li> <li>In some cases (depending on the sensor), the I<sub>2</sub>C lines are shuttle board pin 6 for the clock signal SCL and shuttle board pin 5 for the data line SDA. In such cases pins 17 and 18 may not be connected. Please carefully read the shuttle board documentation.</li> </ul>"},{"location":"coines_api/gpio_mapping/app30_shuttle_board/","title":"GPIO mapping of APP3.0 shuttle board pins","text":"<p>The APP3.0 shuttle board has a total of 16 pins, 7 on the left and 9 on the right.(with shuttle board pins facing downwards).</p> <p>Note:</p> <ul> <li>In coinesAPI the pins are addressed as on the APP3.0 shuttle board. For example, the GPIO #5 is addressed as <code>COINES_MINI_SHUTTLE_PIN_2_6</code>.</li> <li>Supported VDD voltages on APP3.0 board are 0, 1.8V and 2.8V.</li> <li> <p>Supported VDDIO voltage on APP3.0 board is 1.8V.</p> Pin number on shuttle board Name / function Pin number on shuttle board Name / function 1_1 VDD (1.8/2.8V) 2_1 SPI_CS 1_2 VDDIO (1.8) 2_2 SPI: SCK / I<sub>2</sub>C: SCL 1_3 GND 2_3 SPI: MISO / I<sub>2</sub>C: SDO 1_4 GPIO0 2_4 SPI: MOSI /  I<sub>2</sub>C: SDA 1_5 GPIO1 2_5 GPIO4* 1_6 GPIO2 2_6 GPIO5* 1_7 GPIO3 2_7 IOXP_INT* 2_8 PlugDet* 2_9 EEPROM_RW <p>*SPI pins for secondary interface - CS:GPIO4, SCK:GPIO5, MISO:IOXP_INT, MOSI:PlugDet</p> <p>Table 2: Overview of APP3.0 shuttle board pins and their function</p> </li> </ul>"},{"location":"extending_the_usage_of_example_files/data_plotting_and_visualization/","title":"Data plotting and visualization","text":"<p>When compiling an example to run on MCU (for example TARGET=MCU_APP20, see above), the obtained sensor data can easily be plotted in the serial plotter of the Arduino IDE.</p> <p>The example application must print the sensor data to be plotted in a text string, with a terminating new line character. Multiple sensor values per axis are possible. The <code>printf</code> command will stream the sensor data in an ASCII string via (virtual) COM port. Once the user connects to the COM port and opens the Arduino serial plotter, the data will be displayed in a graphical way.</p> <p>Notes and hints:</p> <ul> <li>If the user wants to use an other plotting software, he must consider that the DTR signal line must be set, otherwise the flashed application on the application board will not start running. The serial plotter and serial monitor of Arduino IDE set this signal automatically, other software (like HTerm) have the option to do this manually.</li> <li>The plotting window offers automatic re-sizing. If the user does not want this and needs fixed limits, he could plot the limits as additional lines. Example: <code>printf(\"\\%d \\%d \\%d\\textbackslash n\", lower_limit, sensor_data, upper_limit);</code></li> <li>In case of sensor data with a high offset, such as the output of a barometric pressure sensor, which is usually around 100000 Pa, the user may want to substract a certain offset, so see details of the signal. Example: <code>printf(\"\\%d\\textbackslash n\", (pressure - 99000));</code></li> </ul> <p> </p> Fig. 14: Accelerometer sensor data on Arduino Serial Plotter"},{"location":"extending_the_usage_of_example_files/simple_data_logging/","title":"Simple data logging","text":"<p>The output data generated by the example files can easily be routed into log files for storing of the data. The following code sniplet shows what the user would have to do in principle to generate a log file, stored in the current working directory, on each example execution. The name of the log file is derived from the current time stamp at the time of execution. The code sniplet is valid for examples compiled for PC side (TARGET=PC, see above). If the example is run on the MCU, the data is provided via virtual COM port and the user can use any terminal program to access and store the data.</p> <p>Note that the code snippet does not contain any exception handling, such as checking file overwrite or if fopen returns without error.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) \n{\n    FILE *log_fd;\n    char *logfile = malloc(28);\n    time_t now;\n    struct tm *tm;\n\n    now = time(0);\n    tm = localtime(&amp;now);\n    sprintf(logfile, \"logfile_%04d%02d%02d_%02d%02d%02d.log\", \n        tm-&gt;tm_year+1900, tm-&gt;tm_mon+1, tm-&gt;tm_mday, tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);\n    log_fd = fopen(logfile, \"w\");\n\n    ...\n\n    while(CONDITION)\n    {\n        ...\n        bmaXYZ_get_data(&amp;data);\n        fprintf(log_fd, \"%d, %d, %d\", data.x, data.y, data.z);\n    }\n\n    fclose(log_fd);\n    return 0;\n}\n</code></pre>"},{"location":"installation/system_requirements/","title":"System requirements","text":"<p>COINES should be usable on any recent PC or laptop system which has at least a performance as an \u201coffice PC\u201d. The hardware should provide a USB 2.0 interface.</p> <p>COINES can run on recent versions of Windows and Linux.</p> <p>Tested with following Operating Systems:</p> <ul> <li>Windows 7,10</li> <li>Debian based - Ubuntu 14.04, 16.04, 18.04, Debian Jessie/Stretch</li> <li>Redhat based - CentOS 7 ,Fedora 27  </li> <li>Raspbian (Raspberry Pi 3 hardware)</li> </ul>"},{"location":"installation/installation_linux_macOS/installation_of_coines_linux_macOS/","title":"Installation of COINES","text":"<ul> <li>Download the installer.</li> <li>Use the command <code>cd</code> to go to the directory where the installer is located and make the installer executable:<ul> <li><code>chmod +x coines_vX.Y.sh</code></li> </ul> </li> <li>Ensure that you are connected to the Internet before running the installer, which is executed like this:<ul> <li><code>./coines_vX.Y.sh</code></li> </ul> </li> <li>Accept the End User License agreement.</li> <li>The installer will prompt you if the required dependencies/packages are not installed (This step requires root privileges).</li> </ul>"},{"location":"installation/installation_linux_macOS/installation_of_compiler_environment_linux_macOS/","title":"Installation of compiler environment","text":"<p>On a Debian or Redhat based Linux distro, the installer prompts for installation of missing dependencies, <code>gcc</code>, <code>make</code> and <code>libusb-dev</code> packages. If due to some reason installation fails,the user can manually install the dependencies.</p> <ul> <li>Debian based distros - <code>gcc</code>, <code>make</code>, <code>libusb-1.0-0-dev</code>, <code>dfu-util</code> </li> <li>Redhat based distros - <code>gcc</code>, <code>make</code>, <code>libusbx-devel</code>, <code>dfu-util</code></li> <li>MacOS - <code>libusb</code>, <code>dfu-util</code></li> </ul> <p>If you intend to run the COINES example on Application Board's microcontroller, download the latest version of GNU Embedded Toolchain for ARM for Linux and extract the package. Add the compiler to PATH variable by editing <code>$HOME/.bashrc</code> or similar file like <code>/etc/profile</code> or <code>/etc/environment</code>.</p>"},{"location":"installation/installation_windows/installation_of_coines_windows/","title":"Installation of COINES","text":"<ul> <li>Download the latest version of COINES from Bosch Sensortec's website in the \"Downloads\" section.</li> <li>Run the Installer.</li> <li>Accept the End User License Agreement and click Next.</li> <li>Click Install to start Installation.</li> <li>Click Start --&gt; All  programs --&gt; COINES --&gt; examples --&gt; respective sensors to view examples.</li> </ul>"},{"location":"installation/installation_windows/installation_of_compiler_environment_windows/","title":"Installation of compiler environment","text":"<p>COINES C examples can be built using GNU C compiler (GCC). There are various distributions of GCC. TDM-GCC is easy to install and hence preferred for COINES. TDM GCC is based on MinGW GCC.</p> <p>If you have already installed GCC (MinGW/Cygwin/MSYS2 GCC) and added to 'PATH' environmental variable, you can skip compiler installation.</p> <ol> <li>Download the TDM32/TDM64 bundle (link). Use TDM32 bundle if your Windows OS is 32-bit and TDM64 bundle if 64-bit.</li> <li>Start the Installer. Ensure that the option Check for updated files on the TDM GCC server is unchecked. Click Create and proceed with the installation.</li> <li>If you intend to do run the COINES example on Application Board's microcontroller, install the latest version of GNU Embedded Toolchain for ARM for Windows. Make sure you have checked 'Add path to environmental variable'</li> </ol> <p> </p> Fig. 6: TDM-GCC installation dialog <p> </p> Fig. 7: GNU ARM Toolchain installation"},{"location":"mtp_firmware_for_app30/copying_files_using_mtp/","title":"Copying the files using MTP","text":"<ul> <li>Connect the Application Board 3.0 using USB cable to PC.</li> <li>Turn OFF and turn ON the board with T1 pressed.</li> <li>The device will enumerate as an MTP device with name \"Application Board 3.0\". Click on it and select the \"W25M02 External Memory\".</li> <li>The device will list all the available files and all required files can be copied.</li> </ul> Fig. 15: Copy data log files to the PC over USB MTP"},{"location":"mtp_firmware_for_app30/mtp_firmware_for_app30/","title":"Media Transfer Protocol (MTP) firmware for Application Board 3.0","text":"<p>The external memory chip W25M02/W25N02 on APP3.0 is based on NAND flash.</p> <p>FAT filesystem on NAND flash memory results in a complicated solution which uses of lot of RAM. Moreover use of FAT without Flash Translation Layer (to save RAM) wears out NAND flash with frequent usage. Hence the choice of FlogFS, a filesystem optimized for use with NAND flash.</p> <p>But the use of <code>FlogFS</code>, presents a new problem 'Filesystem access from PC via USB'. Use of <code>FlogFS</code> with USB Mass Storage protocol is not possible because operating system can't recognize <code>FlogFS</code> as a valid filesystem.</p> <p>Use of custom protocol to do filesystem operations would mean re-inventing the wheel and a lot of effort. User also would not have the same experience as with USB Mass Storage.</p> <p>Solution was to go with the \"Media Transfer Protocol\" developed initially by Microsoft for Portable Devices like MP3 players. Starting from Android Kitkat (v4.4), MTP is the only way to access files on an Android device since the whole flash memory (included user storage space) uses filesystems like ext4, YAFFS, F2FS, etc.</p> <p>Files in APP3.0 board's NAND flash memory can be viewed using the USB MTP firmware.</p> <p>Supported on Windows, Linux, Android (via USB OTG) and macOS.</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"mtp_firmware_for_app30/switching_to_mtp_mode/","title":"Switching to MTP mode","text":"<ul> <li>Connect the Application Board 3.0 using USB cable to PC.</li> <li>Application Board 3.0 comes with the preloaded MTP firmware update package.</li> <li>Turn OFF and turn ON the board with T1 pressed. Green LED glows on the board indicating that board switched to MTP mode.</li> </ul> <p>For reference find the examples in following path <code>COINES\\v2.6.0\\examples\\c\\file_handling</code> and run using below command</p> <ul> <li><code>mingw32-make TARGET=MCU_APP30 download</code></li> </ul>"},{"location":"py_api/installation/","title":"Installation","text":"<p>The coinespy module can be installed using pip:</p> <pre><code>pip install coinespy\n</code></pre> <p>Linux users may have to use the below commands due to co-existence of Python 2.7 and Python 3.x</p> <pre><code>pip3 install coinespy\npython3 -m pip install coinespy\n</code></pre> <p>The module can be found on https://pypi.org/project/coinespy/ and also in the COINES installation folder, precisely in the subfolder <code>coines-api\\pc\\python</code>, in which a python wheel package is placed. </p> <p>It is highly recommended that the user is testing the following script (can be found as <code>examples\\python\\coinespy_test.py</code> in the COINES installation) to check if the installation was successful:</p> <pre><code>import coinespy as cpy\nfrom coinespy import ErrorCodes\n\nCOM_INTF = cpy.CommInterface.USB\n\nif __name__ == \"__main__\":\n    board = cpy.CoinesBoard()\n    print(\u2019coinespy version - %s\u2019 % cpy.__version__)\n    board.open_comm_interface(COM_INTF)\n    if board.error_code != ErrorCodes.COINES_SUCCESS:\n        print(f\u2019Could not connect to board: {board.error_code}\u2019)\n    else:\n        b_info = board.get_board_info()\n        print(f\"coines lib version: {board.lib_version}\")\n        print(f\u2019BoardInfo: HW/SW ID: {hex(b_info.HardwareId)}/{hex(b_info.SoftwareId)}\u2019)\n        board.close_comm_interface()\n</code></pre>"},{"location":"py_api/introduction_to_coinespy_library/","title":"Introduction to <code>coinespy</code> library","text":"<p>The <code>coinespy</code> library allows users to access the Bosch Sensortec Application Board using Python. </p> <ul> <li>Control VDD and VDDIO of sensor.</li> <li>Configure SPI and I<sub>2</sub>C bus parameters.</li> <li>Read and write into registers of sensors from Bosch Sensortec via SPI and I<sub>2</sub>C.</li> <li>Read and write digital pins of the Application Board.</li> </ul>"},{"location":"py_api/py_api/","title":"Accessing the Application Board using Python","text":""},{"location":"py_api/py_api/#_1","title":"Accessing the Application Board using Python","text":""},{"location":"py_api/py_api/#_2","title":"Accessing the Application Board using Python","text":""},{"location":"py_api/py_api/#coinespy-api-calls-sensor-communication","title":"coinespy API calls: Sensor communication","text":""},{"location":"py_api/py_api/#read","title":"Read","text":"<p>Reads data from the sensor.</p> <pre><code>data = coinespy.Read(registerAddress, numberofReads=1, sensorInterfaceDetail=None)\n\n# sensorInterfaceDetail:\n#   * SPI configuration: CSB pin (class ShuttleBoardPin)\n#   * I2C configuration: i2c address\n#   * Can be left empty if only one sensor is on the bus. configured through SensorSPIConfig or SensorI2CConfig\n\n# Return: list of retrieved values as int type.\n</code></pre> <p>The CSB pin shall be given as item from ShuttleBoardPin.</p>"},{"location":"py_api/py_api/#write","title":"Write","text":"<p>Writes data to a partcular register.</p> <pre><code>coinespy.Write(registerAddress, registerValue, sensorInterfaceDetail=None)\n\n# registerValue: either a single value of type int or an array of values to be written to the sensor. The function supports burst write (i.e. in case of more than one byte to write, register address is incremented for each following byte). Recommendation is to only write one byte at a time otherwise a long delay after the write command has to be considered.\n\n# sensorInterfaceDetail:\n#   * SPI configuration: CSB pin (class ShuttleBoardPin)\n#   * I2C configuration: i2c address\n#   * Can be left empty if only one sensor is on the bus. configured through SensorSPIConfig or SensorI2CConfig\n</code></pre> <p>The CSB pin shall be given as item from ShuttleBoardPin.</p>"},{"location":"py_api/py_api/#sensori2cconfig","title":"SensorI<sub>2</sub>CConfig","text":"<p>Sets the interface to I<sub>2</sub>C and sets the I<sub>2</sub>C speed.</p> <pre><code>coinespy.SensorI2CConfig(i2cAddress, I2CSPEED speed)\n</code></pre> <p>For the definition of <code>I2CSPEED</code>, refer to I<sub>2</sub>CSPEED.</p>"},{"location":"py_api/py_api/#sensorspiconfig","title":"SensorSPIConfig","text":"<p>Set the interface to SPI and sets the SPI speed and mode.</p> <pre><code>coinespy.SensorSPIConfig(chipSelectPin, SPISPEED spiSpeed=SPISPEED.SPI1000KBIT, SPIMODE spiMode=SPIMODE.MODE0)\n</code></pre> <p>The CSB pin shall be given as item from ShuttleBoardPin.</p> <p>For the definition of <code>SPISPEED</code>, refer to SPISPEED. For the definition of <code>SPIMODE</code>, refer to SPIMODE.</p>"},{"location":"py_api/py_api/#customspiconfig","title":"CustomSPIConfig","text":"<p>Configures the SPI and sets the speed and mode. Difference to the <code>SensorSPIConfig</code> is, that in this function the SPI speed can be given in a free format. Only available for backward-compatibility with GenericAPI.</p> <pre><code>coinespy.CustomSPIConfig(sensorId, chipSelectPin, spiSpeed, SPIMODE spiMode=SPIMODE.MODE0)\n</code></pre> <p>The CSB pin shall be given as item from ShuttleBoardPin.</p> <p>For the definition of <code>SPISPEED</code>, refer to SPISPEED. For the definition of <code>SPIMODE</code>, refer to SPIMODE.</p>"},{"location":"py_api/py_api/#sensor16bitspiconfig","title":"Sensor16bitSPIConfig","text":"<p>Configures SPI for 16-bit read and write.</p> <pre><code>coinespy.Sensor16bitSPIConfig(chipSelectPin, spiSpeed=60, spiMode=SPIMODE.MODE0, spiBits=SPIBITS.SPI16BIT)\n</code></pre>"},{"location":"py_api/py_api/#definiton-of-constants","title":"Definiton of constants","text":""},{"location":"py_api/py_api/#eonoff","title":"EONOFF","text":"<p>Defintion of value for ON and OFF.</p> <pre><code>class EONOFF:\n    OFF = 0\n    ON = 1\n</code></pre>"},{"location":"py_api/py_api/#pinmode","title":"PINMODE","text":"<p>Definition of value for direction state of the pin. Sets to output or input.</p> <pre><code>class PINMODE:\n    INPUT = 0       # COINES_PIN_DIRECTION_IN = 0\n    OUTPUT = 1\n</code></pre>"},{"location":"py_api/py_api/#pinlevel","title":"PINLEVEL","text":"<p>Definition of value for pin level status. Either high or low.</p> <pre><code>class PINLEVEL:\n    LOW = 0         # COINES_PIN_VALUE_LOW = 0\n    HIGH = 1\n</code></pre>"},{"location":"py_api/py_api/#pcinterface","title":"PCINTERFACE","text":"<p>Definition to activate the communication channel.\\newline</p> <pre><code>class PCINTERFACE:\n    USB = 0      # COINES_COMM_INTF_USB\n    SERIAL = 1   # COINES_COMM_INTF_VCOM\n</code></pre>"},{"location":"py_api/py_api/#i2cspeed","title":"I<sub>2</sub>CSPEED","text":"<p>Definition of the I<sub>2</sub>C speed.</p> <pre><code>class I2CSPEED:\n    STANDARDMODE = 0    # Standard mode - 100kHz\n    FASTMODE = 1        # Fast mode - 400kHz\n    HSMODE = 2          # High Speed mode - 3.4 MHz\n    HSMODE2 = 3         # High Speed mode 2 - 1.7 MHz\n</code></pre>"},{"location":"py_api/py_api/#spispeed","title":"SPISPEED","text":"<p>SPI speed definition.</p> <pre><code>class SPISPEED:\n    SPI250KBIT = 240        # COINES_SPI_SPEED_250_KHZ = 240 - 250 kHz */\n    SPI300KBIT = 200\n    SPI400KBIT = 150\n    SPI500KBIT = 120\n    SPI600KBIT = 100\n    SPI750KBIT = 80\n    SPI1000KBIT = 60\n    SPI1200KBIT = 50\n    SPI1250KBIT = 48\n    SPI1500KBIT = 40\n    SPI2000KBIT = 30\n    SPI2500KBIT = 24\n    SPI3000KBIT = 20\n    SPI3750KBIT = 16\n    SPI5000KBIT = 12\n    SPI6000KBIT = 10\n    SPI7500KBIT = 8\n    SPI10000KBIT = 6\n</code></pre>"},{"location":"py_api/py_api/#spibits","title":"SPIBITS","text":"<p>SPI register access width.</p> <pre><code>class SPIBITS:\n    SPI8BIT = 8 # 8 bit register read/write\n    SPI16BIT = 16   # 16 bit register read/write\n</code></pre>"},{"location":"py_api/py_api/#spimode","title":"SPIMODE","text":"<p>SPI MODE definition.</p> <pre><code>class SPIMODE:\n    MODE0 = 0       # SPI Mode 0: CPOL=0; CPHA=0\n    MODE1 = 1       # SPI Mode 1: CPOL=0; CPHA=1\n    MODE2 = 2       # SPI Mode 2: CPOL=1; CPHA=0\n    MODE3 = 3       # SPI Mode 3: CPOL=1; CPHA=1\n</code></pre>"},{"location":"py_api/py_api/#shuttleboardpin","title":"ShuttleBoardPin","text":"<p>Definiton of pins on the shuttle board which can be used as general purpose input/output pins.</p> <pre><code>class ShuttleBoardPin:\n    COINES_SHUTTLE_PIN_7 = 9    # CS pin\n    COINES_SHUTTLE_PIN_8 = 5    # Multi-IO 5\n    COINES_SHUTTLE_PIN_9 = 0    # Multi-IO 0\n    COINES_SHUTTLE_PIN_14 = 1   # Multi-IO 1\n    COINES_SHUTTLE_PIN_15 = 2   # Multi-IO 2\n    COINES_SHUTTLE_PIN_16 = 3   # Multi-IO 3\n    COINES_SHUTTLE_PIN_19 = 8   # Multi-IO 8\n    COINES_SHUTTLE_PIN_20 = 6   # Multi-IO 6\n    COINES_SHUTTLE_PIN_21 = 7   # Multi-IO 7\n    COINES_SHUTTLE_PIN_22 = 4   # Multi-IO 4\n\n# APP3.0 pins\n    COINES_MINI_SHUTTLE_PIN_1_4 = 0x10  # GPIO0\n    COINES_MINI_SHUTTLE_PIN_1_5 = 0x11  # GPIO1\n    COINES_MINI_SHUTTLE_PIN_1_6 = 0x12  # GPIO2/INT1\n    COINES_MINI_SHUTTLE_PIN_1_7 = 0x13  # GPIO3/INT2\n    COINES_MINI_SHUTTLE_PIN_2_5 = 0x14  # GPIO4\n    COINES_MINI_SHUTTLE_PIN_2_6 = 0x15  # GPIO5\n    COINES_MINI_SHUTTLE_PIN_2_1 = 0x16  # CS\n    COINES_MINI_SHUTTLE_PIN_2_3 = 0x17  # SDO\n</code></pre>"},{"location":"py_api/py_api/#multiio","title":"MULTIIO","text":"<p>Definiton of pins on the shuttle board which can be used as general purpose input/output pins (these definitions are only for backward compatibilty, please use those definitions as stated in ShuttleBoardPin).</p> <pre><code>class MULTIIO:\n    MULTIIO_0 = 0\n    MULTIIO_1 = 1\n    MULTIIO_2 = 2\n    MULTIIO_3 = 3\n    MULTIIO_4 = 4\n    MULTIIO_5 = 5\n    MULTIIO_6 = 6\n    MULTIIO_7 = 7\n    MULTIIO_8 = 8\n\n# Old style naming for APP3.0 pins\nclass GPIO:\n    GPIO_0 = 0x10\n    GPIO_1 = 0x11\n    GPIO_2 = 0x12\n    GPIO_3 = 0x13\n    GPIO_4 = 0x14\n    GPIO_5 = 0x15\n</code></pre>"},{"location":"py_api/py_api/#error-codes","title":"Error Codes","text":"<p>Error codes are not (always) returned by the different function calls. Internally, a <code>ERRORCODE</code> variable is maintained which is updated after the function call. It can be read out and checked by the user afterwards. Example:</p> <pre><code>BOARD = coinespy.UserApplicationBoard()\ntry:\n    BOARD.PCInterfaceConfig(PCINTERFACE.USB)\nexcept:\n    print('Board initialization failed: ' + str(BOARD.ERRORCODE))\n    exit(BOARD.ERRORCODE)\n</code></pre>"},{"location":"py_api/py_api/#general-error-codes","title":"General Error Codes","text":"Error Values Description 0 No Error response/Success -1 Failure -2 Length Error -4 Configuration is Unsuccessful -5 Invalid Instruction -6 Memory Error -100 Timeout"},{"location":"py_api/py_api/#pinconfig-specific-error-codes","title":"Pinconfig Specific Error Codes","text":"Error Values Description 1 Analog Switch is turned ON/OFF -10 Invalid Pin -19 Invalid ADC Pin"},{"location":"py_api/py_api/#readwrite-specific-error-codes","title":"Read/Write Specific Error Codes","text":"Error Values Description 2 Default read of 128 bytes is done. Requested bytes of read not supported. For APP2.0 board read more than 128 bytes is possible and up to 1204 bytes -3 The number of bytes that shall be read is 2kB. If this exceeds, error code is updated. -18 For APP2.0 the maximum number of bytes that shall be written for burst operation is 2kB based on RAM requirements. For AB/DB, due to RAM size the maximum number of bytes that shall be written for burst operation is 46 bytes."},{"location":"py_api/py_api/#migration-from-genericapi-to-coinespy","title":"Migration from 'GenericAPI' to coinespy","text":"<p>The attempt was undertaken to keep the names of functions, constants and variables as close as possible to the GenericAPI. To migrate to coinespy, the user should only need to remove the .NET related library (i.e. <code>import clr</code>) and import coinespy as BST, as shown in the example files.</p> <p>Old code may still contain some type conversions which are not necessary anymore. To avoid errors, the user could either modify the code or simply add these lines to his code (at the top of the file):</p> <pre><code>def Byte(value):\n    return value\n\ndef UInt16(value):\n    return value\n\ndef Array(value):\n    return value    \n</code></pre>"},{"location":"py_api/coinespy_api_description/coinespy_api_description/","title":"coinespy API description","text":"<p>As coinespy is only a wrapper on top of coinesAPI, the following API documentation is limited to the wrapper only. Details about meaning of variables and functionality can be found in the corresponding coinesAPI documentation in the chapter above. The following function calls are defined within the class coinesBoard. Thus in order to access the functions, the user has to create an object of that class first.</p> <pre><code>import coinespy as cpy\ncoinesboard = cpy.CoinesBoard()\n</code></pre>"},{"location":"py_api/coinespy_api_description/definition_of_constants/","title":"Definiton of constants","text":""},{"location":"py_api/coinespy_api_description/definition_of_constants/#pindirection","title":"PinDirection","text":"<p>Pin mode definitions. <pre><code>class PinDirection:\n    INPUT = 0 # COINES_PIN_DIRECTION_IN = 0\n    OUTPUT = 1\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#pinvalue","title":"PinValue","text":"<p>Pin level definitions. <pre><code>class PinValue:\n    LOW = 0 # COINES_PIN_VALUE_LOW = 0\n    HIGH = 1\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#comminterface","title":"CommInterface","text":"<p>Definition of Communication interface. <pre><code>class CommInterface:\n    USB = 0\n    SERIAL = 1\n    BLE = 2\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#i2cmode","title":"I2CMode","text":"<p>Definition of the speed of I2C bus. <pre><code>class I2CMode:\n    STANDARD_MODE = 0 # Standard mode - 100kHz\n    FAST_MODE = 1 # Fast mode - 400kHz\n    SPEED_3_4_MHZ = 2 # High Speed mode - 3.4 MHz\n    SPEED_1_7_MHZ = 3 # High Speed mode 2 - 1.7 MHz\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#spispeed","title":"SPISpeed","text":"<p>Definition of the speed of SPI bus. <pre><code>class SPISpeed:\n    SPI_10_MHZ = 6\n    SPI_7_5_MHZ = 8\n    SPI_6_MHZ = 10\n    SPI_5_MHZ = 12\n    SPI_3_75_MHZ = 16\n    SPI_3_MHZ = 20\n    SPI_2_5_MHZ = 24\n    SPI_2_MHZ = 30\n    SPI_1_5_MHZ = 40\n    SPI_1_25_MHZ = 48\n    SPI_1_2_MHZ = 50\n    SPI_1_MHZ = 60\n    SPI_750_KHZ = 80\n    SPI_600_KHZ = 100\n    SPI_500_KHZ = 120\n    SPI_400_KHZ = 150\n    SPI_300_KHZ = 200\n    SPI_250_KHZ = 240\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#spitransferbits","title":"SPITransferBits","text":"<p>Definition of the SPI bits. <pre><code>class SPITransferBits:\n    SPI8BIT = 8 # 8 bit register read/write\n    SPI16BIT = 16 # 16 bit register read/write\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#spimode","title":"SPIMode","text":"<p>Definition of the SPI mode. <pre><code>class SPIMode:\n    MODE0 = 0x00 # SPI Mode 0: CPOL=0; CPHA=0\n    MODE1 = 0x01 # SPI Mode 1: CPOL=0; CPHA=1\n    MODE2 = 0x02 # SPI Mode 2: CPOL=1; CPHA=0\n    MODE3 = 0x03 # SPI Mode 3: CPOL=1; CPHA=1\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#multiiopin","title":"MultiIOPin","text":"<p>Definition of the shuttle board pin(s) <pre><code>class MultiIOPin(Enum):\n    SHUTTLE_PIN_7 = 0x09 # CS pin\n    SHUTTLE_PIN_8 = 0x05 # Multi-IO 5\n    SHUTTLE_PIN_9 = 0x00 # Multi-IO 0\n    SHUTTLE_PIN_14 = 0x01 # Multi-IO 1\n    SHUTTLE_PIN_15 = 0x02 # Multi-IO 2\n    SHUTTLE_PIN_16 = 0x03 # Multi-IO 3\n    SHUTTLE_PIN_19 = 0x08 # Multi-IO 8\n    SHUTTLE_PIN_20 = 0x06 # Multi-IO 6\n    SHUTTLE_PIN_21 = 0x07 # Multi-IO 7\n    SHUTTLE_PIN_22 = 0x04 # Multi-IO 4\n    SHUTTLE_PIN_SDO = 0x1F\n    # APP3.0 pins\n    MINI_SHUTTLE_PIN_1_4 = 0x10 # GPIO0\n    MINI_SHUTTLE_PIN_1_5 = 0x11 # GPIO1\n    MINI_SHUTTLE_PIN_1_6 = 0x12 # GPIO2/INT1\n    MINI_SHUTTLE_PIN_1_7 = 0x13 # GPIO3/INT2\n    MINI_SHUTTLE_PIN_2_5 = 0x14 # GPIO4\n    MINI_SHUTTLE_PIN_2_6 = 0x15 # GPIO5\n    MINI_SHUTTLE_PIN_2_1 = 0x16 # CS\n    MINI_SHUTTLE_PIN_2_3 = 0x17 # SDO\n    MINI_SHUTTLE_PIN_2_7 = 0x1D # GPIO6\n    MINI_SHUTTLE_PIN_2_8 = 0x1E # GPIO7\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#sensorinterface","title":"SensorInterface","text":"<p>To define Sensor interface. <pre><code>class SensorInterface(Enum):\n    SPI = 0\n    I2C = 1\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#i2cbus","title":"I2CBus","text":"<p>Used to define the I2C type. <pre><code>class I2CBus(Enum):\n    BUS_I2C_0 = 0\n    BUS_I2C_1 = 1\n    BUS_I2C_MAX = 2\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#spibus","title":"SPIBus","text":"<p>Used to define the SPI type. <pre><code>class SPIBus(Enum):\n    BUS_SPI_0 = 0\n    BUS_SPI_1 = 1\n    BUS_SPI_MAX = 2\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#pininterruptmode","title":"PinInterruptMode","text":"<p>Defines Pin interrupt modes. <pre><code>class PinInterruptMode(Enum):\n    # Trigger interrupt on pin state change\n    PIN_INTERRUPT_CHANGE = 0\n    # Trigger interrupt when pin changes from low to high\n    PIN_INTERRUPT_RISING_EDGE = 1\n    # Trigger interrupt when pin changes from high to low\n    PIN_INTERRUPT_FALLING_EDGE = 2\n    PIN_INTERRUPT_MODE_MAXIMUM = 4\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#streamingmode","title":"StreamingMode","text":"<p>Streaming mode definitions. <pre><code>class StreamingMode:\n    STREAMING_MODE_POLLING = 0 # Polling mode streaming\n    STREAMING_MODE_INTERRUPT = 1 # Interrupt mode streaming\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#streamingstate","title":"StreamingState","text":"<p>Streaming state definitions. <pre><code>class StreamingState:\n    STREAMING_START = 1\n    STREAMING_STOP = 0\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/definition_of_constants/#samplingunits","title":"SamplingUnits","text":"<p>Sampling Unit definitions. <pre><code>class SamplingUnits:\n    SAMPLING_TIME_IN_MICRO_SEC = 0x01 # sampling unit in micro second\n    SAMPLING_TIME_IN_MILLI_SEC = 0x02 # sampling unit in milli second\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/error_codes/","title":"Error Codes","text":"<p>Error codes are not (always) returned by the different function calls. Internally, an error_code variable is maintained which is updated after the function call. It can be read out and checked by the user afterwards. </p> <p>Example:</p> <pre><code>import coinespy as cpy\nboard = cpy.CoinesBoard()\ntry:\n    board.open_comm_interface(cpy.CommInterface.USB)\n    board.close_comm_interface()\nexcept:\n    print(f\u2019Could not connect to board: {board.error_code}\u2019)\n    exit(board.error_code)\n</code></pre>"},{"location":"py_api/coinespy_api_description/error_codes/#general-error-codes","title":"General Error Codes","text":"<p>Error code definitions <pre><code>class ErrorCodes(Enum):\n    COINES_SUCCESS = 0\n    COINES_E_FAILURE = -1\n    COINES_E_COMM_IO_ERROR = -2\n    COINES_E_COMM_INIT_FAILED = -3\n    COINES_E_UNABLE_OPEN_DEVICE = -4\n    COINES_E_DEVICE_NOT_FOUND = -5\n    COINES_E_UNABLE_CLAIM_INTERFACE = -6\n    COINES_E_MEMORY_ALLOCATION = -7\n    COINES_E_NOT_SUPPORTED = -8\n    COINES_E_NULL_PTR = -9\n    COINES_E_COMM_WRONG_RESPONSE = -10\n    COINES_E_SPI16BIT_NOT_CONFIGURED = -11\n    COINES_E_SPI_INVALID_BUS_INTERFACE = -12\n    COINES_E_SPI_CONFIG_EXIST = -13\n    COINES_E_SPI_BUS_NOT_ENABLED = -14\n    COINES_E_SPI_CONFIG_FAILED = -15\n    COINES_E_I2C_INVALID_BUS_INTERFACE = -16\n    COINES_E_I2C_BUS_NOT_ENABLED = -17\n    COINES_E_I2C_CONFIG_FAILED = -18\n    COINES_E_I2C_CONFIG_EXIST = -19\n    COINES_E_TIMER_INIT_FAILED = -20\n    COINES_E_TIMER_INVALID_INSTANCE = -21\n    COINES_E_TIMER_CC_CHANNEL_NOT_AVAILABLE = -22\n    COINES_E_EEPROM_RESET_FAILED = -23\n    COINES_E_EEPROM_READ_FAILED = -24\n    COINES_E_INIT_FAILED = -25\n    COINES_E_STREAM_NOT_CONFIGURED = -26\n    COINES_E_STREAM_INVALID_BLOCK_SIZE = -27\n    COINES_E_STREAM_SENSOR_ALREADY_CONFIGURED = -28\n    COINES_E_STREAM_CONFIG_MEMORY_FULL = -29\n    COINES_E_INVALID_PAYLOAD_LEN = -30\n    COINES_E_CHANNEL_ALLOCATION_FAILED = -31\n    COINES_E_CHANNEL_DE_ALLOCATION_FAILED = -32\n    COINES_E_CHANNEL_ASSIGN_FAILED = -33\n    COINES_E_CHANNEL_ENABLE_FAILED = -34\n    COINES_E_CHANNEL_DISABLE_FAILED = -35\n    COINES_E_INVALID_PIN_NUMBER = -36\n    COINES_E_MAX_SENSOR_COUNT_REACHED = -37\n    COINES_E_EEPROM_WRITE_FAILED = -38\n    COINES_E_INVALID_EEPROM_RW_LENGTH = -39\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/gpio_oriented_calls/","title":"coinespy API calls: GPIO oriented calls","text":""},{"location":"py_api/coinespy_api_description/coines_api_calls/gpio_oriented_calls/#set_pin_config","title":"set_pin_config","text":"<p>Configures the state, level and direction of a GPIO pin</p> <pre><code>coinesboard.set_pin_config(pin_number: MultiIOPin,direction: PinDirection,output_state: PinValue) -&gt; ErrorCodes\n</code></pre> <p>For the definition of MultiIOPin, refer to 11.3.6.8. For the definition of PinDirection, refer to 11.3.6.1. For PinValue, refer to 11.3.6.2.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/gpio_oriented_calls/#get_pin_config","title":"get_pin_config","text":"<p>Obtains information regarding the Pin\u2019s state, level and direction.</p> <pre><code>PinConfigInfo = coinesboard.get_pin_config(pin_number: MultiIOPin)\n# Return:\nPinConfigInfo.direction # 0: INPUT, 1: OUTPUT\nPinConfigInfo.switch_state # 0: OFF, 1: ON\nPinConfigInfo.level # 1: HIGH, 0: LOW\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/gpio_oriented_calls/#set_shuttleboard_vdd_vddio_config","title":"set_shuttleboard_vdd_vddio_config","text":"<p>Set the VDD and VDDIO voltage level.</p> <pre><code>coinesboard.set_shuttleboard_vdd_vddio_config(vdd_val: float = None, vddio_val: float =\nNone) -&gt; ErrorCodes\n# Example: coinesboard.set_shuttleboard_vdd_vddio_config(3.3, 3.3)\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/gpio_oriented_calls/#set_vdd","title":"set_vdd","text":"<p>Set the VDD voltage level.</p> <pre><code>coinesboard.set_vdd(vdd_val: float = None) -&gt; ErrorCodes\n# Example: coinesboard.set_vdd(3.3)\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/gpio_oriented_calls/#set_vddio","title":"set_vddio","text":"<p>Set the VDDIO voltage level.</p> <pre><code>coinesboard.set_vddio(vdd_val: float = None) -&gt; ErrorCodes\n# Example: coinesboard.set_vddio(3.3)\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/interface_and_board_information/","title":"coinespy API calls: Interface and board information","text":""},{"location":"py_api/coinespy_api_description/coines_api_calls/interface_and_board_information/#open_comm_interface","title":"open_comm_interface","text":"<p>Sets the communication interface between board and PC to USB or Serial.</p> <pre><code>coinesboard.open_comm_interface(interface=CommInterface.USB, arg=None) -&gt; ErrorCodes\n</code></pre> <p>For the definition of CommInterface, refer to 11.3.6.3.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/interface_and_board_information/#close_comm_interface","title":"close_comm_interface","text":"<p>Disposes the resources used by the USB/serial/BLE communication.</p> <pre><code>coinesboard.close_comm_interface(arg=None) -&gt; ErrorCodes\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/interface_and_board_information/#get_board_info","title":"get_board_info","text":"<p>Obtains board specific information.</p> <pre><code>BoardInfo = coinesboard.get_board_info()\n# Return:\nBoardInfo.HardwareId # Hardware ID\nBoardInfo.SoftwareId # Firmware version information\nBoardInfo.Board # Board type\nBoardInfo.ShuttleID # ID of shuttle, in case a shuttle is detected\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/interface_and_board_information/#scan_ble_devices","title":"scan_ble_devices","text":"<p>This API is used to connect to BLE Adapter and return list of BLE peripherals found during BLE scan.</p> <p><pre><code>ble_info, peripheral_count = coinesboard.scan_ble_devices(scan_timeout_ms=0) -&gt; Tuple[list, int]\n</code></pre> For the definition of parameters, refer to 6.8.29.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/interface_and_board_information/#echo_test","title":"echo_test","text":"<p>This API is used to test the communication.</p> <p><pre><code>coinesboard.echo_test(data: List[int]) -&gt; ErrorCodes\n</code></pre> Arguments:</p> <ul> <li><code>data</code>: Data to be sent for testing.</li> </ul>"},{"location":"py_api/coinespy_api_description/coines_api_calls/other/","title":"coinespy API calls: Other useful APIs","text":""},{"location":"py_api/coinespy_api_description/coines_api_calls/other/#flush_interface","title":"flush_interface","text":"<p>Flush the write buffer <pre><code>coinesboard.flush_interface()\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/other/#soft_reset","title":"soft_reset","text":"<p>Resets the device. <pre><code>coinesboard.soft_reset()\n</code></pre></p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/","title":"coinespy API calls: Sensor communication","text":"<p>For the definition of SPIBus, refer to 11.3.6.11. For the definition of I2CBus, refer to 11.3.6.10.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#config_i2c_bus","title":"config_i2c_bus","text":"<p>Configures the I<sub>2</sub>C bus</p> <pre><code>coinesboard.config_i2c_bus(bus: I2CBus, i2c_address: int, i2c_mode: I2CMode) -&gt; ErrorCodes\n</code></pre> <p>For the definition of I2CMode, refer to 11.3.6.4.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#config_spi_bus","title":"config_spi_bus","text":"<p>Configures the SPI bus of the board.</p> <p><pre><code>coinesboard.config_spi_bus(bus: SPIBus, cs_pin: MultiIOPin, spi_speed=SPISpeed,\nspi_mode=SPIMode) -&gt; ErrorCodes\n</code></pre> For the definition of MultiIOPin, refer to 11.3.6.8. For the definition of SPISpeed, refer to 11.3.6.5. For the definition of SPIMode, refer to 11.3.6.7.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#deconfig_i2c_bus","title":"deconfig_i2c_bus","text":"<p>This API is used to de-configure the I<sub>2</sub>C bus</p> <pre><code>coinesboard.deconfig_i2c_bus(bus: I2CBus) -&gt; ErrorCodes\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#deconfig_spi_bus","title":"deconfig_spi_bus","text":"<p>This API is used to de-configure the SPI bus</p> <pre><code>coinesboard.deconfig_spi_bus(bus: SPIBus) -&gt; ErrorCodes\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#write_i2c","title":"write_i2c","text":"<p>Writes 8-bit register data to the I<sub>2</sub>C</p> <p><pre><code>coinesboard.write_i2c(bus: I2CBus, register_address: int, register_value: int,\nsensor_interface_detail: int = None) -&gt; ErrorCodes\n</code></pre> For the definition of parameters, refer to 6.6.7.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#read_i2c","title":"read_i2c","text":"<p>Reads 8-bit register data from the I<sub>2</sub>C</p> <p><pre><code>register_data = coinesboard.read_i2c(bus: I2CBus, register_address: int, number_of_reads=1, sensor_interface_detail: int = None)\n</code></pre> For the definition of parameters, refer to 6.6.8.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#write_spi","title":"write_spi","text":"<p>Writes 8-bit register data to the SPI device.</p> <p><pre><code>coinesboard.write_spi(bus: SPIBus, register_address: int, register_value: int,\nsensor_interface_detail: int = None) -&gt; ErrorCodes\n</code></pre> For the definition of parameters, refer to 6.6.11.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#read_spi","title":"read_spi","text":"<p>Reads 8-bit register data from the SPI device.</p> <p><pre><code>register_data = coinesboard.read_spi(bus: SPIBus, register_address: int,\nnumber_of_reads=1, sensor_interface_detail: int = None)\n</code></pre> For the definition of parameters, refer to 6.6.12.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#config_word_spi_bus","title":"config_word_spi_bus","text":"<p>Configures the SPI bus parameters.</p> <p><pre><code>coinesboard.config_word_spi_bus(bus: SPIBus, cs_pin: MultiIOPin,\nspi_speed=SPISpeed.SPI_1_MHZ, spi_mode=SPIMode.MODE0,\nspi_bits=SPITransferBits.SPI16BIT) -&gt; ErrorCodes\n</code></pre> For the definition of MultiIOPin, refer to 11.3.6.8. For the definition of SPISpeed, refer to 11.3.6.5. For the definition of SPITransferBits, refer to 11.3.6.6.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#write_16bit_spi","title":"write_16bit_spi","text":"<p>Writes 16-bit register data to the SPI device.</p> <p><pre><code>coinesboard.write_16bit_spi(bus: SPIBus, register_address: int, register_value:\nList[int], sensor_interface_detail: int = None) -&gt; ErrorCodes\n</code></pre> For the definition of parameters, refer to 6.6.14.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#read_16bit_spi","title":"read_16bit_spi","text":"<p>Reads 16-bit register data from the SPI device.</p> <p><pre><code>register_data = coinesboard.read_16bit_spi(bus: SPIBus, register_address: int,\nnumber_of_reads=2, sensor_interface_detail: int = None)\n</code></pre> For the definition of parameters, refer to 6.6.15.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#delay_milli_sec","title":"delay_milli_sec","text":"<p>Introduces delay in millisecond.</p> <pre><code>coinesboard.delay_milli_sec(time_in_milli_sec=100)\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/sensor_communication/#delay_micro_sec","title":"delay_micro_sec","text":"<p>Introduces delay in microsecond.</p> <pre><code>coinesboard.delay_micro_sec(time_in_micro_sec=1)\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/streaming_feature/","title":"coinespy API calls: Streaming feature","text":""},{"location":"py_api/coinespy_api_description/coines_api_calls/streaming_feature/#config_streaming","title":"config_streaming","text":"<p>Sets the configuration for streaming sensor data.</p> <pre><code>coinesboard.config_streaming(sensor_id: int,\nstream_config: StreamingConfig, data_blocks: StreamingBlocks) -&gt; ErrorCodes\n</code></pre> <p>Arguments:</p> <ul> <li><code>sensor_id</code> : An integer number that can be used as identifier/index to the sensor data that will be streamed for this setting.  </li> <li><code>stream_config</code> : Contains information regarding interface settings and streaming configuration.</li> <li><code>data_blocks</code> : Contains information regarding numbers of blocks to read, register address and size for each block.</li> </ul> <p>Note:</p> <p>The below parameters should always be set:</p> <ul> <li><code>data_blocks.NoOfBlocks</code> :  number of blocks to stream (must at least be one).</li> <li>For each block b:</li> <li><code>data_blocks.RegStartAddr[b]</code> : start address of the block in the register map</li> <li><code>data_blocks.NoOfDataBytes[b]</code> :  number of bytes to read, starting from the start address</li> </ul> <p>For reading data from I<sub>2</sub>C bus,then set the below parameters:</p> <ul> <li><code>stream_config.Intf</code> = <code>cpy.SensorInterface.I2C.value</code></li> <li><code>stream_config.I2CBus</code> : I2C bus (in case of APP2.0 and APP3.0, this is always <code>cpy.I2CBus.BUS_I2C_0.value</code>)</li> <li><code>stream_config.DevAddr</code> : I2C address of the sensor</li> </ul> <p>For reading data from SPI bus, then set the below parameters:</p> <ul> <li><code>stream_config.Intf</code> = <code>cpy.SensorInterface.SPI.value</code>;</li> <li><code>stream_config.SPIBus</code> : SPI bus (in case of APP2.0 and APP3.0, this is always <code>cpy.SPIBus.BUS_SPI_0.value</code>)</li> <li><code>stream_config.CSPin</code> : CS pin of the sensor, information can be obtained from the shuttle board documentation for the sensor.</li> <li><code>stream_config.SPIType</code>: 0 : 8-bit SPI; 1 : 16-bit SPI</li> </ul> <p>When polling mode is requested, set the below parameters:</p> <ul> <li><code>stream_config.SamplingUnits</code> : either milliseconds or microseconds. Refer to 11.3.6.15.</li> <li><code>stream_config.SamplingTime</code> : Sampling period in the unit as defined in <code>stream_config.SamplingUnits</code>.</li> </ul> <p>When interrupt mode is requested, set the below parameters:</p> <ul> <li><code>stream_config.IntPin</code> : pin of the interrupt which shall trigger the sensor read-out. If the interrupt output of the sensor is used, the required information about the pin number can be obtained from the shuttle board documentation for the sensor.</li> <li><code>stream_config.IntTimeStamp</code>: it can be configured if the sensor data is tagged with a timestamp - 1 or not - 0.</li> <li><code>stream_config.HwPinState</code>: State of the hardware pin connected to the interrupt line - 0/1 : Low/high</li> </ul> <p>Below parameters are common for both streaming types:</p> <ul> <li><code>stream_config.IntlineCount</code> : Number of interrupt lines to be used for monitoring interrupts.</li> <li><code>stream_config.IntlineInfo</code> : List of pin numbers that correspond to interrupt lines being used for interrupt monitoring.</li> <li><code>stream_config.ClearOnWrite</code> : 0/1 : Disable/enable \"clear on write\" feature.</li> </ul> <p>The below parameters should be set only when stream_config.ClearOnWrite = 1:</p> <ul> <li><code>stream_config.ClearOnWriteConfig.StartAddress</code>: Address of the sensor register at which the process of clearOnWrite should initiate.</li> <li><code>stream_config.ClearOnWriteConfig.DummyByte</code>: Number of padding bytes that must be added before clearing the bytes starting from the designated address.</li> <li><code>stream_config.ClearOnWriteConfig.NumBytesToClear</code>: Number of bytes that need to be cleared.</li> </ul> <p>Below is the Python code snippet for interrupt streaming</p> <pre><code># Store streaming settings in local variables\naccel_stream_settings = dict(\n  I2C_ADDR_PRIMARY=0x18,\n  NO_OF_BLOCKS = 2,\n  REG_X_LSB= [0x12, 0x00],\n  NO_OF_DATA_BYTES= [6, 1],\n  CHANNEL_ID=1,\n  CS_PIN=cpy.MultiIOPin.SHUTTLE_PIN_8.value,\n  INT_PIN=cpy.MultiIOPin.SHUTTLE_PIN_21.value,\n  INT_TIME_STAMP=1,\n)\n\ngyro_stream_settings = dict(\n  I2C_ADDR_PRIMARY=0x68,\n  NO_OF_BLOCKS = 2,\n  REG_X_LSB= [0x02,0x00],\n  NO_OF_DATA_BYTES = [6, 1],\n  CHANNEL_ID=2,\n  CS_PIN=cpy.MultiIOPin.SHUTTLE_PIN_14.value,\n  INT_PIN=cpy.MultiIOPin.SHUTTLE_PIN_22.value,\n  INT_TIME_STAMP=1,\n)\n\n# set the config_streaming parameters\nstream_config = cpy.StreamingConfig()\ndata_blocks = cpy.StreamingBlocks()\nif self.interface == cpy.SensorInterface.I2C:\n  stream_config.Intf = cpy.SensorInterface.I2C.value\n  stream_config.I2CBus = cpy.I2CBus.BUS_I2C_0.value\n  stream_config.DevAddr = sensor[\"I2C_ADDR_PRIMARY\"]\n\nelif self.interface == cpy.SensorInterface.SPI:\n  stream_config.Intf = cpy.SensorInterface.SPI.value\n  stream_config.SPIBus = cpy.SPIBus.BUS_SPI_0.value\n  stream_config.CSPin = sensor[\"CS_PIN\"]\n\nif sensor_type == bmi08x.SensorType.ACCEL and self.interface == cpy.SensorInterface.SPI:\n  # extra dummy byte for SPI\n  dummy_byte_offset = 1\nelse:\n  dummy_byte_offset = 0\n\ndata_blocks.NoOfBlocks = sensor[\"NO_OF_BLOCKS\"]\nfor i in range(0, data_blocks.NoOfBlocks):\n  data_blocks.RegStartAddr[i] = sensor[\"REG_X_LSB\"][i]\n  data_blocks.NoOfDataBytes[i] = sensor[\"NO_OF_DATA_BYTES\"][i] + dummy_byte_offset\n\nstream_config.IntTimeStamp = sensor[\"INT_TIME_STAMP\"]\nstream_config.IntPin = sensor[\"INT_PIN\"]\n\n# call config_streaming API for each sensor to configure the streaming settings\nret = coinesboard.config_streaming(\n  accel_sensor_id, self.accel_stream_config, self.accel_data_blocks)\nret = coinesboard.config_streaming(\n  gyro_sensor_id, self.accel_stream_config, self.accel_data_blocks)\n</code></pre>"},{"location":"py_api/coinespy_api_description/coines_api_calls/streaming_feature/#start_stop_streaming","title":"start_stop_streaming","text":"<p>Starts or stops sensor data streaming. <pre><code>coinesboard.start_stop_streaming(stream_mode: StreamingMode, start_stop:\n  StreamingState) -&gt; ErrorCodes\n</code></pre> For the definition of StreamingMode, refer to 11.3.6.13. For the definition of StreamingState, refer to 11.3.6.14.</p>"},{"location":"py_api/coinespy_api_description/coines_api_calls/streaming_feature/#read_stream_sensor_data","title":"read_stream_sensor_data","text":"<p>Reads the data streamed from the sensor. <pre><code>coinesboard.read_stream_sensor_data(sensor_id: int, number_of_samples: int, buffer_size=STREAM_RSP_BUF_SIZE) -&gt; Tuple[ErrorCodes, list, int]\n</code></pre> Return:</p> <p>Tuple of ErrorCodes, data and valid_samples_count For the detailed definition of parameters, refer to 6.7.3.</p>"},{"location":"quickstart/compiling_and_executing_code/","title":"Compiling and executing code (command line)","text":"<ol> <li>Connect the Application Board board via USB, with the sensor shuttle board mounted.</li> <li>Open the command prompt or the terminal.</li> <li>Use the command <code>cd</code> to go to the directory where the example that is to be built is located.</li> <li>Type '<code>mingw32-make</code>' (TDM-GCC/MinGW) or '<code>make</code>' (Linux/Cygwin/MSYS2/MacOS).</li> <li>Run the example and see the output.</li> </ol>"},{"location":"quickstart/cross_compiling_and_downloading_example_to_application_board_microcontroller/","title":"Cross compiling and downloading example to Application Board's microcontroller","text":"<ol> <li>Make sure that GNU Embedded Toolchain for ARM is installed on your PC and added to evironmental variable <code>PATH</code>.</li> <li>Connect the Application board via USB, with the sensor shuttle board mounted.</li> <li>Open the command prompt or the terminal.</li> <li>Use the command <code>cd</code> to go to the directory where the example that is to be built is located. </li> <li> <p>Type <code>mingw32-make TARGET=MCU_APP20 download</code>. Other available options are:</p> Cross-compile for APP2.0 board <code>mingw32-make TARGET=MCU_APP20</code> Download example to APP2.0 MCU RAM <code>mingw32-make LOCATION=RAM TARGET=MCU\\_APP20 download</code> Download example to APP2.0 MCU FLASH <code>mingw32-make LOCATION=FLASH TARGET=MCU\\_APP20 download</code> Download example to APP3.0 MCU RAM <code>mingw32-make LOCATION=RAM TARGET=MCU\\_APP30 download</code> Download example to APP3.0 MCU FLASH* <code>mingw32-make LOCATION=FLASH TARGET=MCU\\_APP30 download</code> Download example to APP3.0 MCU FLASH <code>mingw32-make LOCATION=FLASH TARGET=MCU\\_APP30 download</code> Compile for PC (Default) <code>mingw32-make TARGET=PC</code> Run an example already residing in APP2.0 Flash memory <code>mingw32-make run</code> <p>Linux/MacOS/Cygwin/MSYS2 users can use <code>make</code>.</p> <p>NOTE: Downloading COINES example to APP3.0 Flash memory will overwrite default firmware.</p> </li> <li> <p>Use a Serial Terminal application to view output.</p> <ul> <li>Windows - PuTTY, HTerm,etc.,</li> <li>Linux - <code>cat</code> command. Eg: <code>cat /dev/ttyACM0</code></li> <li>macOS - <code>screen</code> command. Eg: <code>screen /dev/tty.usbmodem9F31</code></li> </ul> </li> <li>For bluetooth, use Serial Bluetooth terminal.</li> </ol> <p>Note:</p> <ul> <li>Some examples may not compile for both PC and MCU target. Please refer to the example documentation or simply the example name (e.g. examples that can only be compiled for the PC are named with a following '_pc').</li> <li>The binary on the MCU will be executed once the serial port is opened. The port must be opened including DTR signal set, otherwise the binary will not be executed. Some terminal programs such as HTerm allow explicit setting of the DTR signal.</li> <li>For printing over APP3.0 bluetooth interface, use <code>fprintf(bt_w,...)</code>.</li> </ul>"},{"location":"quickstart/cross_compiling_and_downloading_example_to_nicla_sense_me_microcontroller/","title":"Cross compiling and downloading example to Nicla Sense ME's microcontroller","text":"<ol> <li>Make sure that GNU Embedded Toolchain for ARM is installed on your PC and added to environmental variable <code>PATH</code>.</li> <li>Connect the Nicla Sense ME board via USB.</li> <li>Open the command prompt or the terminal.</li> <li>Use the command cd to go to the directory where the example that is to be built is located.</li> <li> <p>Type mingw32-make TARGET=MCU_NICLA download . Other available options are:</p> Download example to NICLA MCU FLASH* <code>mingw32-make LOCATION=FLASH TARGET=MCU_NICLA download</code> Compile for PC (Default) <code>mingw32-make TARGET=PC</code> <p>NOTE: Only Coines Bridge example supported in v2.8.8.</p> </li> </ol>"},{"location":"quickstart/eclipse_project_for_examples/","title":"Eclipse project for examples","text":"<ul> <li>Open Eclipse</li> <li> <p>Click File --&gt; New --&gt; C/C++ Project</p> <ol> <li> <p>Input Project name --&gt; Uncheck use default location --&gt; Provide the location of the example folder  Fig. 8: Eclipse C Project for Windows Fig. 9: Eclipse C Project for Linux </p> </li> <li> <p>Select Executable --&gt; Empty project in Project type      </p> </li> <li>For Windows, Select MinGW GCC as Toolchain</li> <li>For Linux, Select Linux GCC as Toolchain     </li> </ol> </li> <li> <p>In Project Explorer window, Right click on the project created --&gt; Click Properties --&gt; C/C++ Build --&gt; Tool Chain Editor --&gt; Select Current builder as Gnu Make Builder</p> </li> <li> <p>Again click on C/C++ Build</p> <ol> <li>For Windows, Uncheck <code>\"Use default build command\"</code> and type build command as <code>mingw32-make</code></li> <li>Uncheck generate Makefiles automatically </li> <li> <p>Ensure Build location path is chosen from the workspace  <p> Fig. 10: Windows Eclipse Project Properties <p> Fig. 11: Linux Eclipse Project Properties </p> <li> <p>Click Apply and Close button</p> </li>"},{"location":"quickstart/eclipse_project_for_examples/#build-project","title":"Build project","text":"<p>In Project Explorer window, Right click on the project --&gt; Click Build Project. The executable file will be generated.</p>"},{"location":"quickstart/eclipse_project_for_examples/#debug-project","title":"Debug project","text":"<ul> <li>Click on Run --&gt; Debug As --&gt; Local C/C++ Application</li> <li>Once launching is completed, Click on <ol> <li>Resume button to run the application</li> <li>Terminate button to stop running the application</li> </ol> </li> </ul> Fig. 12: Eclipse Debug Configuration"},{"location":"updating_bootloader_dd_firmware_and_mtp_firmware/bootloader/","title":"Updating bootloader","text":""},{"location":"updating_bootloader_dd_firmware_and_mtp_firmware/bootloader/#app30-board","title":"App3.0 Board","text":"<ul> <li> <p>Connect the Application Board 3.0 using USB cable to PC.</p> </li> <li> <p>Application Board 3.0 comes preloaded bootloader update package.</p> </li> <li> <p>To update the bootloader run \"update_bootloader.bat\" file present in the following path : </p> </li> <li> <p><code>COINES\\v2.6.0\\firmware\\app3.0\\bootloader_update</code></p> </li> <li> <p>To go to bootloader mode turn OFF and ON the board with T2 pressed, blue LED glows indicating that the board switched to bootloader mode.</p> </li> </ul>"},{"location":"updating_bootloader_dd_firmware_and_mtp_firmware/bootloader/#nicla-sense-me-board","title":"Nicla Sense ME Board","text":"<ul> <li> <p>Connect the Nicla Sense ME board using USB cable to PC.</p> </li> <li> <p>To prepare the board run \"prepare_nicla.bat\" file present in the following path : </p> </li> <li> <p><code>COINES\\v2.8.8\\firmware\\nicla</code></p> </li> <li> <p>To update the bootloader run \"update_bootloader.bat\" file present in the following path :</p> </li> <li> <p><code>COINES\\v2.8.8\\firmware\\nicla\\bootloader_update</code></p> </li> <li> <p>To go to bootloader mode press three times reset button, blue LED glows indicating that the board switched to bootloader mode.</p> </li> </ul>"},{"location":"updating_bootloader_dd_firmware_and_mtp_firmware/coines_bridge_firmware_on_nicla_sense_me/","title":"Updating Coines Bridge firmware on Nicla Sense ME Board","text":"<ul> <li>Connect the Nicla Sense ME board using USB cable to PC.</li> <li>Make sure\"prepare_nicla.bat\" file is executed to flash softdevice and bootloader into Nicla Sense ME board.</li> <li>To update the Coines Bridge firmware run \"update_coines_bridge_flash_fw.bat\" file present in the following path <code>C:\\COINES\\v2.8.8\\firmware\\nicla\\coines_bridge</code></li> <li>To switch to the App mode from bootloader mode, press three times reset button.</li> </ul>"},{"location":"updating_bootloader_dd_firmware_and_mtp_firmware/dd_firmware/","title":"Updating DD firmware","text":"<ul> <li>Connect the Application Board 3.0 using USB cable to PC.</li> <li>Make sure bootloader is flashed into Application board 3.0</li> <li>To update the DD firmware run \"update_dd_fw.bat\" file present in the following path <code>COINES\\v2.6.0\\firmware\\app3.0</code></li> </ul>"},{"location":"updating_bootloader_dd_firmware_and_mtp_firmware/mtp_firmware/","title":"Updating MTP firmware","text":"<ul> <li>Connect the Application Board 3.0 using USB cable to PC.</li> <li>Make sure bootloader is flashed into Application board 3.0</li> <li>To update the MTP firmware run \"update_mtp_fw.bat\" file present in the following path <code>C:\\COINES\\v2.6.0\\firmware\\app3.0\\mtp_fw_update</code></li> <li>To switch to the MTP mode, turn OFF and ON the board with T1 pressed, green LED glows indicating that the board switched to MTP mode.</li> </ul>"},{"location":"usb_ble_dfu_bootloader/invoking_the_bootloader/","title":"Invoking the Bootloader","text":""},{"location":"usb_ble_dfu_bootloader/invoking_the_bootloader/#app30-board","title":"APP3.0 Board","text":"<ul> <li> <p>Hardware</p> <ul> <li>Turn OFF and ON the board with T2 pressed, blue LED glows indicating that the board switched to bootloader mode.</li> </ul> </li> <li> <p>Software</p> <ul> <li> <p>Write 0x4E494F43 ('N','I','O','C') to MAGIC_LOCATION (0x2003FFF4)</p> </li> <li> <p>Write 0x0 or 0xF0000 to APP_START_ADDR (0x2003FFF8)</p> </li> <li> <p>Call NVIC_SystemReset()</p> </li> <li> <p>Invoke Bootloader from Software</p> </li> </ul> <pre><code>#define  MAGIC_LOCATION (0x2003FFF4)\n#define  APP_START_ADDR (*(uint32_t *)(MAGIC_LOCATION+4)\n\n*((uint32_t *)MAGIC_LOCATION) == 0x4E494F43;\nAPP_START_ADDR = 0xF0000;\n//APP_START_ADDR = 0x0;\nNVIC_SystemReset(); \n</code></pre> <ul> <li>The same feature can also be used to perform application switch ( 2 or more applications can reside in the same flash memory at different address locations ). Just write the application start address to APP_START_ADDR instead of bootloader address.</li> </ul> </li> </ul>"},{"location":"usb_ble_dfu_bootloader/invoking_the_bootloader/#nicla-sense-me-board","title":"Nicla Sense ME Board","text":"<ul> <li> <p>Hardware</p> <ul> <li>Press three times reset button, blue LED glows indicating that the board switched to bootloader mode.</li> </ul> </li> <li> <p>Software</p> <ul> <li> <p>Write 0x4E494F43 (\u2019N\u2019,\u2019I\u2019,\u2019O\u2019,\u2019C\u2019) to MAGIC_LOCATION (0x2000F804)</p> </li> <li> <p>Call NVIC_SystemReset()</p> </li> <li> <p>Invoke Bootloader from Software</p> </li> </ul> <pre><code>#define MAGIC_LOCATION (0x2000F804)\n#define APP_START_ADDR (*(uint32_t *)(MAGIC_LOCATION+4)\n*((uint32_t *)MAGIC_LOCATION) == 0x544F4F42;\nNVIC_SystemReset();\n</code></pre> <ul> <li>The same feature can also be used to perform application switch ( 2 or more applications can reside in the same flash memory at different address locations ).Just write the application start address to APP_START_ADDR instead of bootloader address.</li> </ul> </li> </ul>"},{"location":"usb_ble_dfu_bootloader/usb_ble_dfu_bootloader/","title":"USB/BLE DFU bootloader","text":"<p>A USB/BLE Bootloader for APP3.0 Board/nRF52840 and Nicla Sense ME/nRF52832 chip complying with :</p> <ul> <li>https://www.usb.org/sites/default/files/DFU_1.1.pdf</li> <li>https://infocenter.nordicsemi.com/index.jsp?topic=%2Fsdk_nrf5_v17.1.0%2Fble_sdk_app_dfu_bootloader.html&amp;cp=9_1_4_2_3</li> </ul> <p>APP3.0 Board bootloader can be found in the following path <code>COINES\\v2.6.0\\firmware\\app3.0\\bootloader_update</code> and Nicla Sense ME Board bootloader can be found in the following path <code>COINES\\v2.8.8\\firmware\\nicla\\bootloader_update</code></p>"},{"location":"usb_ble_dfu_bootloader/using_with_ble/","title":"Using the Bootloader via BLE","text":"<ul> <li> <p>PC (Windows/Linux and macOS) Python script present in following path <code>COINES\\v2.6.0\\tools\\app30-ble-dfu</code> can use the binary file directly.</p> <ol> <li> <p>Scan for devices to find BLE MAC address using below command.</p> <ul> <li>python app30-ble-dfu.py -l</li> </ul> </li> <li> <p>Update firmware by using MAC address obtained in the previous step and firmware BIN file.</p> <ul> <li>python app30-ble-dfu.py -d D7:A3:CE:8E:36:14 -f firmware.bin</li> </ul> </li> </ol> </li> <li> <p>Android devices</p> <ol> <li> <p>Generate ZIP package using https://pypi.org/project/adafruit-nrfutil/ before using nRF ToolBox for BLE or nRF connect for mobile.</p> <ul> <li>adafruit-nrfutil dfu genpkg --dev-type 0x0052 --application firmware.bin dfu-package.zip</li> </ul> </li> </ol> <p>Note : Not applicable for Nicla Sense ME board</p> </li> </ul>"},{"location":"usb_ble_dfu_bootloader/using_with_usb/","title":"Using the Bootloader via USB","text":"<p>Write firmware to Flash memory using following command</p> <ul> <li>dfu-util -a FLASH -D fw.bin -R</li> </ul> <p>Write firmware to RAM memory using following command</p> <ul> <li>dfu-util -a RAM -D fw.bin -R</li> </ul> <p>Read firmware from Flash memory using following command</p> <ul> <li>dfu-util -a FLASH -U fw_bkup.bin</li> </ul> <p>Read firmware from RAM memory using following command</p> <ul> <li>dfu-util -a RAM -U fw_bkup.bin</li> </ul> <p>Read device serial number/ BLE MAC address</p> <ul> <li>dfu-util -l</li> </ul> <p>Note : Not applicable for Nicla Sense ME board</p>"},{"location":"usb_ble_dfu_bootloader/key_features/ble_dfu/","title":"BLE DFU","text":"<ul> <li>Code download to FLASH.</li> <li>Works with PC and mobile devices with iOS/Android.</li> </ul> <p>Bootloader was written taking into account the following aspects : </p> <ul> <li>Usability<ol> <li>No special driver installation or admin rights should be required.</li> <li>The update process should be straight forward.</li> </ol> </li> <li>Maintainability<ol> <li>Open source community takes care of PC side tools. For eg: dfu-util is a cross platform tool.</li> <li>Use Google Chrome's WebUSB to update firmware. https://devanlai.github.io/webdfu/dfu-util/</li> </ol> </li> <li>Size</li> <li>COINES on MCU.</li> </ul>"},{"location":"usb_ble_dfu_bootloader/key_features/usb_dfu/","title":"USB DFU","text":"<ul> <li>Code download to RAM or FLASH.</li> <li>Code read back (upload) from  RAM or FLASH (Useful for taking firmware backups).</li> <li>Works with Windows, Linux, macOS and Android.</li> </ul>"}]}